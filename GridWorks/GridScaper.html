<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GridScaper Prototype — Span-to-Span Clearance</title>
  <style>
    html,body,#c{margin:0;height:100%;overflow:hidden;font-family:sans-serif}
    #hud{position:fixed;top:8px;left:8px;background:#0008;color:#fff;padding:6px 10px;font-size:12px;line-height:1.4;border-radius:6px;user-select:none}
    #hud input[type="range"],#hud select{vertical-align:middle}
    #hud label{margin-right:4px}
    #jsonPanel{
      position: absolute;
      top: 0;
      right: 0;
      width: 310px;
      margin: 8px;
      background-color: #1a1a1a;
      color: #efefef;
      font-family: 'Lucida Grande', sans-serif;
      font-size: 11px;
      border-radius: 6px;
      overflow: hidden;
      z-index: 1000;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    }
    .panel-title {
      padding: 8px;
      background: #323232;
      color: #efefef;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #2c2c2c;
    }
    .panel-title:hover {
      background: #3a3a3a;
    }
    .panel-content {
      max-height: calc(100vh - 120px);
      overflow: auto;
    }
    .panel-folder {
      margin-bottom: 4px;
      border-bottom: 1px solid #2c2c2c;
    }
    .panel-folder-title {
      padding: 8px;
      cursor: pointer;
      background-color: #262626;
      display: flex;
      justify-content: space-between;
    }
    .panel-folder-title:hover {
      background-color: #2f2f2f;
    }
    .panel-folder-content {
      padding: 8px;
      overflow: hidden;
      transition: height 0.3s ease;
      background-color: #1a1a1a;
    }
    .folder-collapsed .panel-folder-content {
      height: 0 !important;
      padding: 0;
    }
    .json-key { color: #9cdcfe; }
    .json-string { color: #ce9178; }
    .json-number { color: #b5cea8; }
    .json-boolean { color: #569cd6; }
    .json-null { color: #777777; }
    .json-row {
      padding: 4px 8px;
      display: flex;
      justify-content: space-between;
    }
    .json-row:nth-child(odd) {
      background-color: #222222;
    }
    .json-value {
      text-align: right;
    }
  </style>
  <script src="https://unpkg.com/three@0.139.2/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.139.2/examples/js/controls/OrbitControls.js"></script>
  <script type="module" src="json-view.js"></script>
</head>
<body>
  <div id="hud">
    <div><strong>Left-click</strong>: add pole • <strong>Right-click</strong>: delete pole</div>
    <label>New pole height: <input id="heightSlider" type="range" min="1" max="40" step="1" value="20"></label>
    <span id="heightLabel">20</span> ft
    &nbsp;&nbsp;|&nbsp;&nbsp;
    <label>Terrain: <select id="terrainSelect"><option value="flat" selected>Flat</option><option value="hills">Rolling Hills</option><option value="hillsTrees">Hills + Trees</option></select></label>
    &nbsp;&nbsp;|&nbsp;&nbsp;
    <label>Tension: <input id="tensionSlider" type="range" min="0.2" max="5" step="0.1" value="1"></label>
    <span id="tensionLabel">1.0×</span>
    &nbsp;&nbsp;|&nbsp;&nbsp;
    <label><input type="checkbox" id="showGridCheck" checked> Grid</label>
    &nbsp;&nbsp;|&nbsp;&nbsp;
    <label>Setting: <select id="settingSelect"><option value="residential" selected>Residential</option><option value="commercial">Commercial</option><option value="urban">Urban</option><option value="rural">Rural</option></select></label>
    &nbsp;&nbsp;|&nbsp;&nbsp;
    <label>Environment: <select id="environmentSelect"><option value="coastal" selected>Coastal</option><option value="mountain">Mountain</option><option value="desert">Desert</option><option value="city">City</option></select></label>
    &nbsp;&nbsp;|&nbsp;&nbsp;
    <label>Equipment: <select id="equipmentSelect"><option value="distribution" selected>Distribution</option><option value="subTransmission">Sub Transmission</option><option value="bulkTransmission">Bulk Transmission</option><option value="generation">Generation</option></select></label>
    &nbsp;&nbsp;|&nbsp;&nbsp;
    <button id="downloadJSON">Download</button>
    <button id="clearScene">Clear Scene</button>
  </div>
  <canvas id="c"></canvas>
  </div>

<script>
/* ------- constants ------- */
const CLEARANCE = 1;          // ft span‑to‑span
const SAMPLES   = 32;         // points per span
const DRAG_SENS = 0.05;       // ft per pixel when dragging pole
const MINH = 1, MAXH = 40;
const SNAP = v=>Math.round(v);

/* ------- UI refs ------- */
const slider = document.getElementById('heightSlider');
const hLabel = document.getElementById('heightLabel');
const terrainSel = document.getElementById('terrainSelect');
const tensionSlider = document.getElementById('tensionSlider');
const tensionLabel = document.getElementById('tensionLabel');
const settingSel = document.getElementById('settingSelect');
const environmentSel = document.getElementById('environmentSelect');
const equipmentSel = document.getElementById('equipmentSelect');
const clearBtn = document.getElementById('clearScene');
const showGridCheck = document.getElementById('showGridCheck');
let currentH = +slider.value;
let currentTension = +tensionSlider.value;
slider.oninput = ()=>{ currentH=+slider.value; hLabel.textContent=currentH; updateGhost(); };
terrainSel.onchange = ()=>{ buildTerrain(); resetScene(); updateSceneElements(); };
tensionSlider.oninput = ()=>{ currentTension=+tensionSlider.value; tensionLabel.textContent=currentTension.toFixed(1)+'×'; rebuild(); };

if (settingSel) settingSel.onchange = updateSceneElements;
if (environmentSel) environmentSel.onchange = ()=>{ updateSceneElements(); updateEnvironment(); };
if (equipmentSel) equipmentSel.onchange = updateSceneElements;
if (showGridCheck) showGridCheck.onchange = ()=>{ toggleGridVisibility(showGridCheck.checked); };

clearBtn.onclick = resetScene;

/* ------- three basics ------- */
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas,antialias:true});
renderer.setSize(innerWidth,innerHeight);
const scene = new THREE.Scene(); scene.background=new THREE.Color(0x87ceeb);
const camera = new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,1000);
camera.position.set(40,40,40);
const controls = new THREE.OrbitControls(camera,renderer.domElement); controls.enableDamping=true;
scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));
const sun = new THREE.DirectionalLight(0xffffff,0.6); sun.position.set(10,40,20); scene.add(sun);

/* ------- terrain & trees ------- */
const SIZE=120, SEG=120;

const urlParams = new URLSearchParams(window.location.search);

// Parse pole parameters from URL and normalize if needed
const poleDistances = urlParams.get('poles-distances')?.split(',').map(Number).filter(v => !isNaN(v)) || [];
const poleHeights = urlParams.get('poles-heights')?.split(',').map(Number).filter(v => !isNaN(v)) || [];
const poleElevations = urlParams.get('poles-elevations')?.split(',').map(Number).filter(v => !isNaN(v)) || [];

// Create default elevations (zeros) if distances and heights exist but elevations are missing
let useElevations = poleElevations;
if (poleDistances.length > 0 && poleHeights.length > 0 && poleElevations.length === 0) {
  useElevations = Array(Math.min(poleDistances.length, poleHeights.length)).fill(0);
}

// Parse URL parameters for grid dimensions
const sizeX = Math.max(parseInt(urlParams.get('size-x')) || SIZE, Math.max(...poleDistances) + 20);
const sizeY = Math.max(parseInt(urlParams.get('size-y')) || SIZE, Math.max(...poleDistances) + 20);

let customPoles = null;
if (poleDistances.length && poleHeights.length && 
    poleDistances.length === poleHeights.length && 
    poleDistances.length === useElevations.length) {

  // Maintain height-to-distance proportions during scaling
  const normalizeData = () => {
    const maxDistance = Math.max(...poleDistances);
    const minDistance = Math.min(...poleDistances);
    const distRange = maxDistance - minDistance;
    
    const maxHeight = Math.max(...poleHeights);
    const minHeight = Math.min(...poleHeights);
    const heightRange = maxHeight - minHeight;
    
    const maxElev = Math.max(...useElevations);
    const minElev = Math.min(...useElevations);
    const elevRange = maxElev - minElev;
    
    let scaledDistances = [...poleDistances];
    let scaledHeights = [...poleHeights];
    let scaledElevations = [...useElevations];
    let scaling = false;
    let heightToDistanceRatio = heightRange / Math.max(1, distRange);
    
    // Scale if any dimension is too large
    if (distRange > 100 || maxHeight > 40 || elevRange > 30) {
      scaling = true;
      
      // Scale distances if needed
      if (distRange > 100) {
        const targetDistRange = 50;
        const distScaleFactor = targetDistRange / distRange;
        scaledDistances = poleDistances.map(d => minDistance + (d - minDistance) * distScaleFactor);
        console.log(`Scaling distances: ${distRange}ft → ${targetDistRange}ft (factor: ${distScaleFactor.toFixed(2)})`);
        
        // Proportionally adjust heights based on distance scaling to maintain aspect ratio
        const targetHeightRange = heightRange * distScaleFactor;
        scaledHeights = poleHeights.map(h => (h - minHeight) * distScaleFactor + minHeight);
        console.log(`Proportionally adjusting heights to maintain ${heightToDistanceRatio.toFixed(2)} height-to-distance ratio`);
      } 
      // Independent height scaling if needed
      else if (maxHeight > 40) {
        const heightScaleFactor = 35 / maxHeight;
        scaledHeights = poleHeights.map(h => h * heightScaleFactor);
        console.log(`Scaling heights: max ${maxHeight}ft → 35ft (factor: ${heightScaleFactor.toFixed(2)})`);
      }
      
      // Scale elevations if needed
      if (elevRange > 30) {
        const targetElevRange = 20;
        const elevScaleFactor = targetElevRange / elevRange;
        scaledElevations = useElevations.map(e => minElev + (e - minElev) * elevScaleFactor);
        console.log(`Scaling elevations: range ${elevRange}ft → ${targetElevRange}ft (factor: ${elevScaleFactor.toFixed(2)})`);
      }
      
      console.log("Proportional scaling applied to maintain realistic simulation");
    }
    
    return { 
      distances: scaledDistances, 
      heights: scaledHeights, 
      elevations: scaledElevations,
      scaling 
    };
  };

  const { distances, heights, elevations, scaling } = normalizeData();
  
  if (!scaling) {
    console.log("Using original pole parameters (no scaling needed)");
  }

  customPoles = distances.map((x, i) => ({ x, h: heights[i], elev: elevations[i] }));
}

// Define the base height calculation function
function calculateTerrainHeight(x, z) {
  return terrainSel.value === 'flat' ? 0 : Math.sin(x*0.09)*5 + Math.cos(z*0.11)*3 + Math.sin((x+z)*0.04)*2;
}

// Custom ground function for sloped surface through pole elevations
let customGround = null;
if (customPoles) {
  customGround = (x, z) => {
    // Convert world Z to local coordinate system
    const localZ = z - terrainOffsetZ;
    
    // For points before the first pole or after the last pole
    if (localZ <= customPoles[0].x) return customPoles[0].elev;
    if (localZ >= customPoles[customPoles.length-1].x) return customPoles[customPoles.length-1].elev;
    
    // Find the two closest poles for interpolation
    for (let i = 1; i < customPoles.length; i++) {
      if (localZ <= customPoles[i].x) {
        const t = (localZ - customPoles[i-1].x) / (customPoles[i].x - customPoles[i-1].x);
        // Linear interpolation between pole elevations
        return customPoles[i-1].elev * (1-t) + customPoles[i].elev * t;
      }
    }
    
    // Fallback
    return 0;
  };
}

// Height at specific location function
function hAt(x, z) {
  if (customGround) {
    return customGround(x, z);
  }
  return calculateTerrainHeight(x, z);
}

let terrain=null; const trees=new THREE.Group(); scene.add(trees); const treeData=[]; // {x,z,yTop,ref}
let terrainOffsetZ = 0;

// Add grid lines and labels
function addGridLines() {
  scene.children.filter(o => o.userData.grid).forEach(g => {
    scene.remove(g);
    if (g.geometry) g.geometry.dispose();
  });

  const gridGroup = new THREE.Group();
  gridGroup.userData.grid = true;
  gridGroup.userData.labels = [];

  const gridMaterial = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });
  
  // Get terrain dimensions and position
  let terrainWidth = 100;
  let terrainDepth = 100;
  let terrainPosition = { x: 0, z: 0 };
  
  if (terrain) {
    terrainWidth = terrain.geometry.parameters.width;
    terrainDepth = terrain.geometry.parameters.height;
    terrainPosition.z = terrain.position.z;
  }
  
  // Calculate grid bounds to match terrain
  const startX = -terrainWidth / 2;
  const endX = terrainWidth / 2;
  const startZ = -terrainDepth / 2 + terrainPosition.z;
  const endZ = terrainDepth / 2 + terrainPosition.z;

  // Create grid lines at 10-foot intervals (X direction)
  for (let i = Math.ceil(startX / 10) * 10; i <= Math.floor(endX / 10) * 10; i += 10) {
    const points = [];
    
    // Sample points along Z-axis to follow terrain
    for (let z = startZ; z <= endZ; z += 1) {
      const y = hAt(i, z) + 0.05; // Slight offset to avoid z-fighting
      points.push(new THREE.Vector3(i, y, z));
    }
    
    const geometryX = new THREE.BufferGeometry().setFromPoints(points);
    const lineX = new THREE.Line(geometryX, gridMaterial);
    gridGroup.add(lineX);

    if (i !== 0) {
      const labelX = document.createElement('div');
      labelX.className = 'grid-label';
      labelX.textContent = `${i}`;
      labelX.style.position = 'absolute';
      labelX.style.color = 'black';
      labelX.style.backgroundColor = 'rgba(255,255,255,0.5)';
      labelX.style.padding = '2px 4px';
      labelX.style.borderRadius = '2px';
      labelX.style.fontSize = '10px';
      labelX.style.userSelect = 'none';
      labelX.style.pointerEvents = 'none';
      document.body.appendChild(labelX);

      gridGroup.userData.labels.push({
        element: labelX,
        position: new THREE.Vector3(i, hAt(i, startZ) + 0.1, startZ),
        axis: 'x'
      });
    }
  }

  // Create grid lines at 10-foot intervals (Z direction)
  for (let i = Math.ceil(startZ / 10) * 10; i <= Math.floor(endZ / 10) * 10; i += 10) {
    const points = [];
    
    // Sample points along X-axis to follow terrain
    for (let x = startX; x <= endX; x += 1) {
      const y = hAt(x, i) + 0.05; // Slight offset to avoid z-fighting
      points.push(new THREE.Vector3(x, y, i));
    }
    
    const geometryZ = new THREE.BufferGeometry().setFromPoints(points);
    const lineZ = new THREE.Line(geometryZ, gridMaterial);
    gridGroup.add(lineZ);

    if (i !== 0) {
      const labelZ = document.createElement('div');
      labelZ.className = 'grid-label';
      labelZ.textContent = `${i}`;
      labelZ.style.position = 'absolute';
      labelZ.style.color = 'black';
      labelZ.style.backgroundColor = 'rgba(255,255,255,0.5)';
      labelZ.style.padding = '2px 4px';
      labelZ.style.borderRadius = '2px';
      labelZ.style.fontSize = '10px';
      labelZ.style.userSelect = 'none';
      labelZ.style.pointerEvents = 'none';
      document.body.appendChild(labelZ);

      gridGroup.userData.labels.push({
        element: labelZ,
        position: new THREE.Vector3(startX, hAt(startX, i) + 0.1, i),
        axis: 'z'
      });
    }
  }

  scene.add(gridGroup);
}

function toggleGridVisibility(visible) {
  scene.children.filter(o => o.userData.grid).forEach(g => {
    g.visible = visible;
    
    if (g.userData.labels) {
      g.userData.labels.forEach(label => {
        label.element.style.display = visible ? 'block' : 'none';
      });
    }
  });
}

function clearSceneElements() {
  scene.children.filter(o => o.userData.environmentElement).forEach(e => {
    scene.remove(e);
    if (e.geometry) e.geometry.dispose();
  });
}

function updateEnvironment() {
  // Clear existing environment elements
  clearSceneElements();
  
  // Add environment-specific elements
  if (environmentSel.value === 'coastal') {
    addCoastalElements();
  } else if (environmentSel.value === 'mountain') {
    addMountainElements();
  } else if (environmentSel.value === 'desert') {
    addDesertElements();
  } else if (environmentSel.value === 'city') {
    addCityElements();
  }
  
  // Update terrain color based on environment
  updateTerrainColor();
}

function updateTerrainColor() {
  if (!terrain) return;
  
  let terrainColor = 0x5ca55c; // Default green
  
  switch(environmentSel.value) {
    case 'desert':
      terrainColor = 0xd2b48c; // Beige for desert
      break;
    case 'coastal':
      terrainColor = 0xf0e68c; // Khaki for sandy shores
      break;
    case 'mountain':
      terrainColor = 0x4f7942; // Dark green for mountain vegetation
      break;
    case 'city':
      terrainColor = 0x7ccd7c; // Lighter green for manicured urban grass
      break;
  }
  
  terrain.material.color.setHex(terrainColor);
}

function addCoastalElements() {
  // Add water body
  const waterWidth = 80;
  const waterDepth = terrain ? terrain.geometry.parameters.height : 100;
  const terrainPos = terrain ? terrain.position.z : 0;
  const terrainWidth = terrain ? terrain.geometry.parameters.width : 100;
  
  // Create reflective water material
  const waterMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x1e90ff, 
    transparent: true, 
    opacity: 0.8,
    metalness: 0.9,
    roughness: 0.1,
    envMapIntensity: 1.5
  });
  
  // Main water body
  const waterGeometry = new THREE.PlaneGeometry(waterWidth, waterDepth, 32, 24);
  const water = new THREE.Mesh(waterGeometry, waterMaterial);
  water.rotation.x = -Math.PI / 2;
  water.position.set(-terrainWidth/2 - waterWidth/2, 0.1, terrainPos);
  water.userData.environmentElement = true;
  water.userData.isWater = true;
  scene.add(water);
  
  // Create gentle waves by animating vertices
  const waterPositions = water.geometry.attributes.position;
  water.userData.waveInfo = {
    originalPositions: [...Array(waterPositions.count)].map((_, i) => ({
      x: waterPositions.getX(i),
      y: waterPositions.getY(i),
      z: waterPositions.getZ(i)
    })),
    time: 0
  };
  
  // Add foam at shoreline
  const foamGeometry = new THREE.PlaneGeometry(2, waterDepth, 1, 8);
  const foamMaterial = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.7,
    side: THREE.DoubleSide
  });
  
  const foam = new THREE.Mesh(foamGeometry, foamMaterial);
  foam.rotation.x = -Math.PI / 2;
  foam.position.set(-terrainWidth/2, 0.12, terrainPos);
  foam.userData.environmentElement = true;
  foam.userData.isWaterFoam = true;
  scene.add(foam);
  
  // Add dock
  const dockGeometry = new THREE.BoxGeometry(5, 0.5, 15);
  const dockMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
  const dock = new THREE.Mesh(dockGeometry, dockMaterial);
  dock.position.set(-terrainWidth/2 + 2.5, 0.3, terrainPos - 5);
  dock.userData.environmentElement = true;
  scene.add(dock);
  
  // Add palm trees
  const trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, 5, 8);
  const trunkMat = new THREE.MeshStandardMaterial({ color: 0xcd853f });
  const palmGeo = new THREE.SphereGeometry(2, 8, 6, 0, Math.PI * 2, 0, Math.PI / 2);
  palmGeo.scale(1, 0.3, 1);
  const palmMat = new THREE.MeshStandardMaterial({ color: 0x32cd32 });
  
  for (let i = 0; i < 6; i++) {
    const group = new THREE.Group();
    
    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = 2.5;
    group.add(trunk);
    
    const palm = new THREE.Mesh(palmGeo, palmMat);
    palm.position.y = 5;
    palm.rotation.x = -Math.PI/6;
    group.add(palm);
    
    // Position along shoreline with slight randomization
    const x = Math.random() * 10 - terrainWidth/2 + 5;
    const z = (Math.random() - 0.5) * waterDepth * 0.8 + terrainPos;
    group.position.set(x, 0, z);
    
    group.userData.environmentElement = true;
    scene.add(group);
  }
  
  // Add a simple road
  addRoad(terrainPos, terrainWidth, waterDepth);
}

function addMountainElements() {
  if (!terrain) return;
  
  // Add pine trees
  const terrainWidth = terrain.geometry.parameters.width;
  const terrainDepth = terrain.geometry.parameters.height;
  const terrainPos = terrain.position.z;
  
  // Pine trees
  const trunkGeo = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
  const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
  const pineGeo = new THREE.ConeGeometry(1.5, 4, 8);
  const pineMat = new THREE.MeshStandardMaterial({ color: 0x2f4f4f });
  
  for (let i = 0; i < 15; i++) {
    const group = new THREE.Group();
    
    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = 1;
    group.add(trunk);
    
    // Add 3 cone sections for the pine tree
    for (let j = 0; j < 3; j++) {
      const pine = new THREE.Mesh(pineGeo, pineMat);
      const scale = 1 - j * 0.2;
      pine.scale.set(scale, scale, scale);
      pine.position.y = 3 + j * 1.2;
      group.add(pine);
    }
    
    // Random position avoiding center line
    const xPos = (Math.random() - 0.5) * terrainWidth;
    const xOffset = Math.abs(xPos) < 5 ? (xPos < 0 ? -3 : 3) : 0;
    const finalX = xPos + xOffset;
    
    const zPos = (Math.random() - 0.5) * terrainDepth + terrainPos;
    const yPos = hAt(finalX, zPos);
    
    group.position.set(finalX, yPos, zPos);
    group.userData.environmentElement = true;
    scene.add(group);
  }
  
  // Rocks
  const rockGeo = new THREE.DodecahedronGeometry(1, 0);
  const rockMat = new THREE.MeshStandardMaterial({ color: 0x808080 });
  
  for (let i = 0; i < 12; i++) {
    const rock = new THREE.Mesh(rockGeo, rockMat);
    
    // Random scaling and rotation for variety
    const scale = 0.5 + Math.random() * 1.5;
    rock.scale.set(
      scale * (0.8 + Math.random() * 0.4),
      scale * (0.7 + Math.random() * 0.6),
      scale * (0.8 + Math.random() * 0.4)
    );
    
    rock.rotation.set(
      Math.random() * Math.PI,
      Math.random() * Math.PI,
      Math.random() * Math.PI
    );
    
    // Position randomly
    const xPos = (Math.random() - 0.5) * terrainWidth;
    const zPos = (Math.random() - 0.5) * terrainDepth + terrainPos;
    const yPos = hAt(xPos, zPos);
    
    rock.position.set(xPos, yPos, zPos);
    rock.userData.environmentElement = true;
    scene.add(rock);
  }
  
  // Mountain path/road
  const roadWidth = 3;
  const roadGeometry = new THREE.PlaneGeometry(roadWidth, terrainDepth * 0.9);
  const roadMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x8B4513,
    roughness: 1
  });
  
  const road = new THREE.Mesh(roadGeometry, roadMaterial);
  road.rotation.x = -Math.PI / 2;
  road.position.set(terrainWidth * 0.3, 0.05, terrainPos);
  road.userData.environmentElement = true;
  scene.add(road);
}

function addDesertElements() {
  if (!terrain) return;
  
  const terrainWidth = terrain.geometry.parameters.width;
  const terrainDepth = terrain.geometry.parameters.height;
  const terrainPos = terrain.position.z;
  
  // Saguaro cacti
  const cactusBodyGeo = new THREE.CylinderGeometry(0.5, 0.7, 6, 8);
  const cactusArmGeo = new THREE.CylinderGeometry(0.3, 0.3, 2.5, 8);
  const cactusMat = new THREE.MeshStandardMaterial({ color: 0x2F4F2F });
  
  for (let i = 0; i < 8; i++) {
    const cactusGroup = new THREE.Group();
    
    // Main body
    const body = new THREE.Mesh(cactusBodyGeo, cactusMat);
    body.position.y = 3;
    cactusGroup.add(body);
    
    // Add 1-3 arms
    const armCount = Math.floor(Math.random() * 3) + 1;
    
    for (let a = 0; a < armCount; a++) {
      const arm = new THREE.Mesh(cactusArmGeo, cactusMat);
      const height = 2 + Math.random() * 2;
      const side = a === 0 ? 1 : (a === 1 ? -1 : (Math.random() > 0.5 ? 1 : -1));
      
      arm.position.set(
        0.6 * side,
        height,
        0
      );
      arm.rotation.z = side * Math.PI / 6;
      cactusGroup.add(arm);
    }
    
    // Position randomly on terrain
    const xPos = (Math.random() - 0.5) * terrainWidth;
    const xOffset = Math.abs(xPos) < 5 ? (xPos < 0 ? -3 : 3) : 0;
    const finalX = xPos + xOffset;
    
    const zPos = (Math.random() - 0.5) * terrainDepth + terrainPos;
    const yPos = hAt(finalX, zPos);
    
    cactusGroup.position.set(finalX, yPos, zPos);
    cactusGroup.userData.environmentElement = true;
    scene.add(cactusGroup);
  }
  
  // Tumbleweeds
  const tumbleweedGeo = new THREE.SphereGeometry(0.8, 8, 8);
  const tumbleweedMat = new THREE.MeshStandardMaterial({ 
    color: 0xA0522D, 
    wireframe: true,
    wireframeLinewidth: 2
  });
  
  for (let i = 0; i < 6; i++) {
    const tumbleweed = new THREE.Mesh(tumbleweedGeo, tumbleweedMat);
    
    // Random scale and rotation
    const scale = 0.6 + Math.random() * 0.8;
    tumbleweed.scale.set(scale, scale * 0.8, scale);
    tumbleweed.rotation.set(
      Math.random() * Math.PI,
      Math.random() * Math.PI,
      Math.random() * Math.PI
    );
    
    // Position randomly
    const xPos = (Math.random() - 0.5) * terrainWidth;
    const zPos = (Math.random() - 0.5) * terrainDepth + terrainPos;
    const yPos = hAt(xPos, zPos) + 0.4;
    
    tumbleweed.position.set(xPos, yPos, zPos);
    tumbleweed.userData.environmentElement = true;
    scene.add(tumbleweed);
  }
  
  // Desert road
  const roadWidth = 5;
  const roadGeometry = new THREE.PlaneGeometry(roadWidth, terrainDepth);
  const roadMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xC2B280, 
    roughness: 0.9
  });
  
  const road = new THREE.Mesh(roadGeometry, roadMaterial);
  road.rotation.x = -Math.PI / 2;
  road.position.set(-terrainWidth * 0.3, 0.05, terrainPos);
  road.userData.environmentElement = true;
  scene.add(road);
}

function addCityElements() {
  if (!terrain) return;
  
  const terrainWidth = terrain.geometry.parameters.width;
  const terrainDepth = terrain.geometry.parameters.height;
  const terrainPos = terrain.position.z;
  
  // Main road
  const mainRoadWidth = 8;
  const mainRoadGeometry = new THREE.PlaneGeometry(mainRoadWidth, terrainDepth);
  const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
  
  const mainRoad = new THREE.Mesh(mainRoadGeometry, roadMaterial);
  mainRoad.rotation.x = -Math.PI / 2;
  mainRoad.position.set(0, 0.05, terrainPos);
  mainRoad.userData.environmentElement = true;
  scene.add(mainRoad);
  
  // Cross streets
  const crossRoadCount = 3;
  const crossRoadWidth = 6;
  
  for (let i = 0; i < crossRoadCount; i++) {
    const crossRoadGeometry = new THREE.PlaneGeometry(terrainWidth, crossRoadWidth);
    const crossRoad = new THREE.Mesh(crossRoadGeometry, roadMaterial);
    crossRoad.rotation.x = -Math.PI / 2;
    
    const offset = (i - 1) * terrainDepth / 3;
    crossRoad.position.set(0, 0.06, terrainPos + offset);
    crossRoad.userData.environmentElement = true;
    scene.add(crossRoad);
  }
  
  // Urban trees (round tops)
  const trunkGeo = new THREE.CylinderGeometry(0.2, 0.3, 2, 8);
  const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
  const canopyGeo = new THREE.SphereGeometry(1.2, 12, 12);
  const canopyMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
  
  for (let i = 0; i < 12; i++) {
    const tree = new THREE.Group();
    
    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = 1;
    tree.add(trunk);
    
    const canopy = new THREE.Mesh(canopyGeo, canopyMat);
    canopy.position.y = 2.5;
    tree.add(canopy);
    
    // Position along streets
    const roadSide = Math.random() > 0.5;
    const crossStreet = Math.floor(Math.random() * 3);
    
    let xPos, zPos;
    
    if (Math.random() > 0.5) {
      // Along main road
      xPos = mainRoadWidth/2 + 2;
      if (roadSide) xPos = -xPos;
      zPos = (Math.random() - 0.5) * (terrainDepth - 10) + terrainPos;
    } else {
      // Along cross streets
      xPos = (Math.random() - 0.5) * (terrainWidth - 10);
      const offset = (crossStreet - 1) * terrainDepth / 3;
      zPos = offset + terrainPos + (roadSide ? 5 : -5);
    }
    
    const yPos = hAt(xPos, zPos);
    tree.position.set(xPos, yPos, zPos);
    tree.userData.environmentElement = true;
    scene.add(tree);
  }
}

function addRoad(terrainPos, terrainWidth, terrainDepth) {
  const roadWidth = 5;
  const roadGeometry = new THREE.PlaneGeometry(roadWidth, terrainDepth * 0.8);
  const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
  
  const road = new THREE.Mesh(roadGeometry, roadMaterial);
  road.rotation.x = -Math.PI / 2;
  road.position.set(terrainWidth * 0.25, 0.05, terrainPos);
  road.userData.environmentElement = true;
  scene.add(road);
}

function buildTerrain() {
  if (terrain) {
    scene.remove(terrain);
    terrain.geometry.dispose();
  }
  
  // Clear existing scene elements
  clearSceneElements();
  trees.clear();
  treeData.length = 0;

  let terrainWidth = 100;
  let terrainDepth = 100;

  if (customPoles && customPoles.length > 0) {
    terrainWidth = 20;
    const minZ = Math.min(...customPoles.map(p => p.x));
    const maxZ = Math.max(...customPoles.map(p => p.x));
    terrainDepth = (maxZ - minZ) + 40;
    terrainOffsetZ = 0;
  }

  console.log(`Building terrain surface: ${terrainWidth}x${terrainDepth} units`);
  console.log(`X bounds: ${-terrainWidth/2} to ${terrainWidth/2}`);
  console.log(`Z bounds: ${-20} to ${terrainDepth-20}`);

  const g = new THREE.PlaneGeometry(terrainWidth, terrainDepth, SEG, SEG);
  g.rotateX(-Math.PI / 2);

  // Set terrain color based on environment
  let terrainColor = 0x5ca55c; // Default green
  if (environmentSel && environmentSel.value === 'desert') {
    terrainColor = 0xd2b48c; // Beige for desert
  }

  terrain = new THREE.Mesh(g, new THREE.MeshStandardMaterial({ 
    color: terrainColor, 
    side: THREE.DoubleSide 
  }));
  terrain.position.z = terrainDepth/2 - 20;
  scene.add(terrain);

  const positions = terrain.geometry.attributes.position;
  for (let i = 0; i < positions.count; i++) {
    const x = positions.getX(i);
    const localZ = positions.getZ(i);
    const worldZ = localZ + terrain.position.z;

    let elevation = 0;
    if (customGround) {
      elevation = customGround(x, worldZ);
    } else {
      elevation = calculateTerrainHeight(x, worldZ);
    }

    positions.setY(i, elevation);
  }

  positions.needsUpdate = true;
  terrain.geometry.computeVertexNormals();

  addGridLines();

  if (terrainSel.value === 'hillsTrees') addDefaultTrees();
  
  // Add environment-specific elements
  if (environmentSel) {
    updateEnvironment();
  }
}

function addDefaultTrees(){
  const trunkG=new THREE.CylinderGeometry(0.15,0.15,1,6);
  const folG=new THREE.ConeGeometry(0.75,2,8);
  const trunkM=new THREE.MeshStandardMaterial({color:0x8b5a2b});
  const folM=new THREE.MeshStandardMaterial({color:0x2e8b57});
  const cluster=20,radius=6;
  for(let cx=-SIZE/2;cx<=SIZE/2;cx+=cluster){
    for(let cz=-SIZE/2;cz<=SIZE/2;cz+=cluster){ if(Math.random()<0.35){
      const n=THREE.MathUtils.randInt(6,15);
      for(let i=0;i<n;i++){
        const ang=Math.random()*Math.PI*2, r=Math.random()*radius;
        const x=cx+Math.cos(ang)*r, z=cz+Math.sin(ang)*r, y=hAt(x,z); const s=THREE.MathUtils.randFloat(0.8,1.6);
        const trunk=new THREE.Mesh(trunkG,trunkM); trunk.scale.y=s; trunk.position.set(x,y+s*0.5,z);
        const fol=new THREE.Mesh(folG,folM); fol.scale.setScalar(s); fol.position.set(x,y+s*1.5,z);
        const t=new THREE.Group(); t.add(trunk); t.add(fol); t.userData.tree=true; trees.add(t);
        treeData.push({x,z,yTop:y+s*1.5,ref:t});
      } }} }
}
buildTerrain();

/* ------- materials ------- */
const BASE_H=10, R=0.2;
const poleGeo = new THREE.CylinderGeometry(R,R,BASE_H,8);
const crossArmGeo = new THREE.BoxGeometry(3, 0.2, 0.2);
const mPole   = new THREE.MeshStandardMaterial({color:0x8b5a2b});
const mCrossArm = new THREE.MeshStandardMaterial({color:0x4d4d4d});
const mPoleHL = new THREE.MeshStandardMaterial({color:0xffe66d});
const mGood   = new THREE.LineBasicMaterial({color:0x000000});
const mBad    = new THREE.LineBasicMaterial({color:0xff0000});
const mGhost  = new THREE.MeshStandardMaterial({color:0x46c9ff,transparent:true,opacity:0.4});
const mTreeHL = new THREE.MeshStandardMaterial({color:0xffff8d});
const mGrid   = new THREE.LineBasicMaterial({color:0x555555, transparent:true, opacity:0.5});
const mBird   = new THREE.MeshStandardMaterial({color:0x222222});

/* ------- bird creation ------- */
const birds = [];
const birdSettings = {
  count: 3,
  perchHeight: 0.1,
  flySpeed: 5.0,
  wingSpeed: 0.2,
  spawnChance: 0.25
};

/* ------- data stores ------- */
const poles=[]; // {x,z,h,base,obj}
const ray=new THREE.Raycaster(); const mouse=new THREE.Vector2();

/* ------- span build & check ------- */
function drawSpan(a, b) {
  const yA = a.base + a.h;
  const yB = b.base + b.h;
  const d = Math.hypot(b.x - a.x, b.z - a.z);
  const sag = Math.max(0.1, d * 0.05) / currentTension;
  
  // Draw two parallel conductors
  for (let conductorOffset = -1; conductorOffset <= 1; conductorOffset += 2) {
    const pts = [];
    
    for (let i = 0; i <= SAMPLES; i++) {
      const t = i / SAMPLES;
      const x = THREE.MathUtils.lerp(a.x, b.x, t) + conductorOffset * 0.5;
      const z = THREE.MathUtils.lerp(a.z, b.z, t) + terrainOffsetZ;
      const y = THREE.MathUtils.lerp(yA, yB, t) - sag * Math.sin(Math.PI * t);
      pts.push(new THREE.Vector3(x, y, z));
    }
    
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const line = new THREE.Line(geo, mGood);
    line.userData = { span: true, a: a.obj, b: b.obj };
    scene.add(line);
  }
}
function rebuild() {
  // Store existing spans before clearing
  const oldSpans = scene.children.filter(o => o.userData.span);
  
  // Clear only spans
  scene.children.filter(o => o.userData.span).forEach(l => {
    l.geometry.dispose();
    scene.remove(l);
  });
  
  const initialLoad = !window.spansInitialized;
  if (initialLoad && customPoles) {
    window.spansInitialized = true;
  }
  
  // Draw spans between poles
  for (let i = 1; i < poles.length; i++) {
    drawSpan(poles[i-1], poles[i]);
  }
  
  // Only initialize birds if this is the first load or there were no spans before
  if (initialLoad || oldSpans.length === 0) {
    initBirds();
  }
}

/* ------- pole helpers ------- */
function addPole(x, z, h) {
  if (poles.some(p => p.x === x && p.z === z)) return;

  const base = hAt(x, z + terrainOffsetZ);
  const mesh = new THREE.Mesh(poleGeo, mPole);
  mesh.scale.y = h / BASE_H;
  mesh.position.set(x, base + h / 2, z + terrainOffsetZ);
  mesh.userData.pole = true;

  const crossArm = new THREE.Mesh(crossArmGeo, mCrossArm);
  crossArm.position.y = 5;  
  mesh.add(crossArm);

  scene.add(mesh);
  poles.push({ x, z, h, base, obj: mesh });
  rebuild();
}
function removePole(obj){ const i=poles.findIndex(p=>p.obj===obj); if(i>-1){scene.remove(obj); poles.splice(i,1); rebuild();}}

/* ------- ghost pole ------- */
let ghost=new THREE.Mesh(poleGeo,mGhost); ghost.visible=false; scene.add(ghost);
let hoverPt=null, hoverPole=null, hoverTree=null;

// Adjust terrain alignment and raycasting logic
function updateGhost() {
  ghost.visible = false;
  if (!hoverPt || hoverPole || hoverTree) return;
  if (poles.some(p => p.x === hoverPt.x && p.z === hoverPt.z)) return;

  const h = currentH;
  const base = hAt(hoverPt.x, hoverPt.z + terrainOffsetZ); // Adjusted to account for terrainOffsetZ

  ghost.scale.y = h / BASE_H;
  ghost.position.set(hoverPt.x, base + h / 2, hoverPt.z + terrainOffsetZ); // Adjusted to align with terrainOffsetZ
  ghost.visible = true;
}

/* ------- picking helpers ------- */
function pick(evt,list){ mouse.set((evt.clientX/innerWidth)*2-1,-(evt.clientY/innerHeight)*2+1); ray.setFromCamera(mouse,camera); return ray.intersectObjects(list,true)[0]?.object||null; }
const poleMeshes=()=>poles.map(p=>p.obj);
function setTreeHL(t,on){ t.traverse(m=>{if(m.isMesh)m.material=on?mTreeHL:(m.geometry.type==='CylinderGeometry'?new THREE.MeshStandardMaterial({color:0x8b5a2b}):new THREE.MeshStandardMaterial({color:0x2e8b57}));}); }

/* ------- interaction state ------- */
let drag=null,startY=0,startH=0,clickStart=null;
let dragStartPos = null, dragStartHeight = null, dragMode = null;

window.addEventListener('contextmenu', e => {
  e.preventDefault(); // Prevent the default context menu
  const tPick = pick(e, trees.children);
  if (tPick) {
    trees.remove(tPick);
    treeData.splice(treeData.findIndex(t => t.ref === tPick), 1);
    rebuild();
    return;
  }
  
  const pPick = pick(e, poleMeshes());
  if (pPick) {
    removePole(pPick);
    return;
  }
});

window.addEventListener('pointerdown', e => {
  if (e.shiftKey) {
    return;
  }

  const pPick = pick(e, poleMeshes());
  if (pPick) {
    drag = pPick;
    startY = e.clientY;
    startX = e.clientX;
    const pole = poles.find(p => p.obj === drag);
    dragStartPos = { x: pole.x, z: pole.z };
    dragStartHeight = pole.h;
    controls.enabled = false;
    
    // If Alt key is pressed, prepare for height adjustment
    if (e.altKey) {
      dragMode = 'height';
    } else {
      dragMode = 'position';
    }
    return;
  }
  clickStart = [e.clientX, e.clientY];
});

window.addEventListener('pointermove', e => {
  // Handle pole dragging
  if (drag) {
    mouse.set((e.clientX / innerWidth) * 2 - 1, -(e.clientY / innerHeight) * 2 + 1);
    ray.setFromCamera(mouse, camera);
    const hit = ray.intersectObject(terrain, true)[0];
    
    if (hit) {
      const pole = poles.find(p => p.obj === drag);
      
      if (dragMode === 'position') {
        pole.x = SNAP(hit.point.x);
        pole.z = SNAP(hit.point.z - terrainOffsetZ);
        
        const base = hAt(pole.x, pole.z + terrainOffsetZ);
        pole.base = base;
        pole.obj.position.set(pole.x, base + pole.h / 2, pole.z + terrainOffsetZ);
      } else if (dragMode === 'height') {
        const deltaY = startY - e.clientY;
        const newHeight = Math.max(MINH, Math.min(MAXH, dragStartHeight + deltaY * DRAG_SENS));
        pole.h = SNAP(newHeight);
        pole.obj.scale.y = pole.h / BASE_H;
        pole.obj.position.y = pole.base + pole.h / 2;
      }
      
      rebuild();
    }
    return;
  }

  const pPick = pick(e, poleMeshes());
  if (pPick !== hoverPole) {
    if (hoverPole) hoverPole.material = mPole;
    hoverPole = pPick;
    if (hoverPole) hoverPole.material = mPoleHL;
  }

  const tPick = pick(e, trees.children);
  if (tPick !== hoverTree) {
    if (hoverTree) setTreeHL(hoverTree, false);
    hoverTree = tPick;
    if (hoverTree) setTreeHL(hoverTree, true);
  }

  mouse.set((e.clientX / innerWidth) * 2 - 1, -(e.clientY / innerHeight) * 2 + 1);
  ray.setFromCamera(mouse, camera);
  const hit = ray.intersectObject(terrain, true)[0];

  if (hit) {
    hoverPt = {
      x: SNAP(hit.point.x),
      z: SNAP(hit.point.z - terrainOffsetZ),
    };
  } else {
    hoverPt = null;
  }

  updateGhost();
});

window.addEventListener('pointerup', e => {
  if (drag) {
    drag = null;
    controls.enabled = true;
    return;
  }
  if (!clickStart) return;
  const [dx, dy] = [Math.abs(e.clientX - clickStart[0]), Math.abs(e.clientY - clickStart[1])];
  clickStart = null;
  if (dx < 5 && dy < 5 && hoverPt) {
    const h = currentH;
    const base = hAt(hoverPt.x, hoverPt.z + terrainOffsetZ);
    addPole(hoverPt.x, hoverPt.z, h);
    updateGhost();
  }
});

function resetScene(){ poles.forEach(p=>scene.remove(p.obj)); poles.length=0; scene.children.filter(o=>o.userData.span).forEach(l=>{l.geometry.dispose();scene.remove(l);}); updateGhost(); birds.length = 0;}

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* ------- geometric calculations ------- */
function round2(value) {
  return value === null ? null : parseFloat(value.toFixed(2));
}

function calculateDistance(p1, p2) {
  return Math.hypot(p2.x - p1.x, p2.z - p1.z);
}

function calculateAngle(p1, p2) {
  return Math.atan2(p2.z - p1.z, p2.x - p1.x) * (180 / Math.PI);
}

function calculateInclinationAngle(p1, p2) {
  const dx = p2.x - p1.x;
  const dz = p2.z - p1.z;
  const dy = (p2.base + p2.h) - (p1.base + p1.h);
  const horizontalDistance = Math.hypot(dx, dz);
  
  return Math.atan2(dy, horizontalDistance) * (180 / Math.PI);
}

function calculateCatenaryAngles(p1, p2, tensionFactor) {
  const horizontalDistance = calculateDistance(p1, p2);
  if (horizontalDistance === 0) return { departureAngle: 0, arrivalAngle: 0 };
  
  const height1 = p1.base + p1.h;
  const height2 = p2.base + p2.h;
  const heightDiff = height2 - height1;
  
  const sag = Math.max(0.1, horizontalDistance * 0.05) / tensionFactor;
  
  const baseSlopeAngle = Math.atan2(heightDiff, horizontalDistance);
  const sagEffect = Math.atan(Math.PI * sag / horizontalDistance);
  
  const departureAngle = (baseSlopeAngle + sagEffect) * (180 / Math.PI);
  const arrivalAngle = (baseSlopeAngle - sagEffect) * (180 / Math.PI);
  
  return { departureAngle, arrivalAngle };
}

function calculateSpanLength(p1, p2, sag) {
  const distance = calculateDistance(p1, p2);
  if (distance === 0) return 0;
  
  // Approximate the conductor length with discrete integration over catenary curve
  const segments = 50;
  let length = 0;
  const height1 = p1.base + p1.h;
  const height2 = p2.base + p2.h;
  
  for (let i = 0; i < segments; i++) {
    const t1 = i / segments;
    const t2 = (i + 1) / segments;
    
    const x1 = p1.x + (p2.x - p1.x) * t1;
    const z1 = p1.z + (p2.z - p1.z) * t1;
    const y1 = height1 + (height2 - height1) * t1 - sag * Math.sin(Math.PI * t1);
    
    const x2 = p1.x + (p2.x - p1.x) * t2;
    const z2 = p1.z + (p2.z - p1.z) * t2;
    const y2 = height1 + (height2 - height1) * t2 - sag * Math.sin(Math.PI * t2);
    
    length += Math.hypot(x2 - x1, y2 - y1, z2 - z1);
  }
  
  return length;
}

function calculateTopAngle(p1, p2, p3) {
  const angle1 = calculateAngle(p2, p1);
  const angle2 = calculateAngle(p2, p3);
  
  let diff = Math.abs(angle2 - angle1);
  if (diff > 180) diff = 360 - diff;
  
  return diff;
}


function collectData() {
  const polesData = poles.map((p, index) => {
    const nextPole = index < poles.length - 1 ? poles[index + 1] : null;
    const prevPole = index > 0 ? poles[index - 1] : null;
    
    const distanceToNext = nextPole ? calculateDistance(p, nextPole) : 0;
    const sag = nextPole ? Math.max(0.1, distanceToNext * 0.05) / currentTension : 0;
    
    let departureAngle = null;
    let arrivalAngle = null;
    
    if (nextPole) {
      const angles = calculateCatenaryAngles(p, nextPole, currentTension);
      departureAngle = angles.departureAngle;
    }
    
    if (prevPole) {
      const angles = calculateCatenaryAngles(prevPole, p, currentTension);
      arrivalAngle = angles.arrivalAngle;
    }
    
    const topAngle = (prevPole && nextPole) ? calculateTopAngle(prevPole, p, nextPole) : null;
    
    return {
      id: index + 1,
      x: round2(p.x),
      z: round2(p.z),
      height: round2(p.h),
      baseElevation: round2(p.base),
      nextPoleId: nextPole ? index + 2 : null,
      distanceToNext: round2(distanceToNext),
      arrivalAngle: round2(arrivalAngle),
      departureAngle: round2(departureAngle),
      topAngle: round2(topAngle)
    };
  });
  
  const spansData = [];
  for (let i = 0; i < poles.length - 1; i++) {
    const a = poles[i];
    const b = poles[i + 1];
    const distance = calculateDistance(a, b);
    const sag = Math.max(0.1, distance * 0.05) / currentTension;
    const angles = calculateCatenaryAngles(a, b, currentTension);
    const straightLineSlope = calculateInclinationAngle(a, b);
    
    const span = scene.children.find(o => 
      o.userData.span && 
      o.userData.a === a.obj && 
      o.userData.b === b.obj
    );
    
    spansData.push({
      fromPoleId: i + 1,
      toPoleId: i + 2,
      distance: round2(distance),
      length: round2(calculateSpanLength(a, b, sag)),
      departureAngle: round2(angles.departureAngle),
      arrivalAngle: round2(angles.arrivalAngle),
      sagDistance: round2(sag),
      straightLineSlope: round2(straightLineSlope),
      valid: span ? span.material === mGood : false
    });
  }
  
  return {
    poles: polesData,
    spans: spansData,
    terrain: terrainSel.value,
    tensionMultiplier: currentTension
  };
}

// Place custom poles on load
if (customPoles) {
  poles.length = 0;
  
  // Extract any scaling factor that was applied to the elevations
  let elevScaleFactor = 1;
  const elevRange = Math.max(...useElevations) - Math.min(...useElevations);
  if (elevRange > 30) {
    const targetElevRange = 20;
    elevScaleFactor = targetElevRange / elevRange;
    console.log(`Using elevation scale factor for pole heights: ${elevScaleFactor.toFixed(2)}`);
  }
  
  for (const pole of customPoles) {
    const mesh = new THREE.Mesh(poleGeo, mPole);
    
    // Scale pole height proportionally if elevations were scaled
    const scaledHeight = elevScaleFactor !== 1 ? pole.h * elevScaleFactor : pole.h;
    mesh.scale.y = scaledHeight / BASE_H;
    
    const zPos = pole.x;
    const base = pole.elev;
    
    mesh.position.set(0, base + scaledHeight / 2, zPos + terrainOffsetZ);
    mesh.userData.pole = true;

    // Add cross arm to the pole
    const crossArm = new THREE.Mesh(crossArmGeo, mCrossArm);
    crossArm.position.y = 5;
    mesh.add(crossArm);

    scene.add(mesh);
    poles.push({ x: 0, z: zPos, h: scaledHeight, base, obj: mesh });
  }
  rebuild();
}

// Scene customization variables
const sceneElements = {
  buildings: [],
}

function updateSceneElements() {
  console.log(`Updating scene for ${settingSel.value} setting in ${environmentSel.value} environment with ${equipmentSel.value} equipment`);
  
  // Remove existing buildings
  sceneElements.buildings.forEach(b => scene.remove(b));
  sceneElements.buildings = [];
  
  // Update pole colors and materials based on equipment type
  updatePoleAppearance();
  
  // Add buildings based on setting type
  addRandomBuildings();
}

function updatePoleAppearance() {
  let poleColor, crossArmColor;
  
  // Set colors based on equipment type
  switch(equipmentSel.value) {
    case 'distribution':
      poleColor = 0x8b5a2b; // Brown wood poles
      crossArmColor = 0x4d4d4d; // Dark gray crossarms
      break;
    case 'subTransmission':
      poleColor = 0x708090; // Gray steel poles
      crossArmColor = 0x303030; // Darker gray crossarms/brackets
      break;
    case 'bulkTransmission':
      poleColor = 0xa9a9a9; // Silver lattice towers
      crossArmColor = 0xa9a9a9; // Same color for lattice crossarms
      break;
    case 'generation':
      poleColor = 0x708090; // Gray steel
      crossArmColor = 0x1e90ff; // Blue accent for generation
      break;
  }
  
  // Update all existing poles
  poles.forEach(pole => {
    pole.obj.material.color.setHex(poleColor);
    
    // Update crossarms if they exist
    pole.obj.children.forEach(child => {
      if (child.geometry.type === 'BoxGeometry') {
        child.material.color.setHex(crossArmColor);
      }
    });
  });
  
  // Update materials for future poles
  mPole.color.setHex(poleColor);
  mCrossArm.color.setHex(crossArmColor);
}

function addRandomBuildings() {
  // Clear existing buildings
  sceneElements.buildings.forEach(b => scene.remove(b));
  sceneElements.buildings = [];
  
  if (!terrain) return;
  
  // Get terrain dimensions
  const terrainWidth = terrain.geometry.parameters.width;
  const terrainDepth = terrain.geometry.parameters.height;
  const terrainPos = terrain.position.z;
  
  // Building density and size range based on setting
  let buildingCount = 0;
  let minSize = 1;
  let maxSize = 3;
  let maxHeight = 2;
  
  switch(settingSel.value) {
    case 'residential':
      buildingCount = 8; // Sparse houses
      minSize = 2;
      maxSize = 4;
      maxHeight = 2.5;
      break;
    case 'commercial': 
      buildingCount = 5; // Fewer but larger buildings
      minSize = 4;
      maxSize = 8;
      maxHeight = 6;
      break;
    case 'urban':
      buildingCount = 12; // Many buildings
      minSize = 3;
      maxSize = 8;
      maxHeight = 15;
      break;
    case 'rural':
      buildingCount = 3; // Very few structures
      minSize = 2;
      maxSize = 5;
      maxHeight = 3;
      break;
  }
  
  // Building color based on environment
  let buildingColor;
  switch(environmentSel.value) {
    case 'coastal':
      buildingColor = 0xf5f5dc; // Beige/tan beach buildings
      break;
    case 'mountain':
      buildingColor = 0x8b4513; // Brown wood cabins
      break;
    case 'desert':
      buildingColor = 0xd2b48c; // Tan/adobe buildings
      break;
    case 'city':
      buildingColor = 0xa9a9a9; // Gray city buildings
      break;
  }
  
  const buildingMaterial = new THREE.MeshStandardMaterial({ color: buildingColor });
  
  // Add random buildings
  for (let i = 0; i < buildingCount; i++) {
    // Random position within terrain bounds, but avoid the center path where poles are
    const xPos = (Math.random() - 0.5) * (terrainWidth - 4);
    // If abs(xPos) < 5, then we're too close to the center line, so push out
    const xOffset = Math.abs(xPos) < 5 ? (xPos < 0 ? -5 : 5) : 0;
    const finalX = xPos + xOffset;
    
    const zPos = (Math.random() - 0.5) * (terrainDepth - 4) + terrainPos;
    const width = minSize + Math.random() * (maxSize - minSize);
    const depth = minSize + Math.random() * (maxSize - minSize);
    const height = 1 + Math.random() * (maxHeight - 1);
    
    const yPos = hAt(finalX, zPos) + height / 2;
    
    const buildingGeo = new THREE.BoxGeometry(width, height, depth);
    const building = new THREE.Mesh(buildingGeo, buildingMaterial);
    building.position.set(finalX, yPos, zPos);
    
    // Slightly rotate buildings for more natural look
    building.rotation.y = Math.random() * Math.PI * 0.25;
    
    scene.add(building);
    sceneElements.buildings.push(building);
  }
}

/* ------- bird creation ------- */
function createBird() {
  const group = new THREE.Group();
  
  // Bird body
  const bodyGeo = new THREE.ConeGeometry(0.15, 0.5, 4);
  bodyGeo.rotateX(Math.PI / 2);
  const body = new THREE.Mesh(bodyGeo, mBird);
  group.add(body);
  
  // Head
  const headGeo = new THREE.SphereGeometry(0.08, 8, 8);
  const head = new THREE.Mesh(headGeo, mBird);
  head.position.set(0.2, 0.08, 0);
  group.add(head);
  
  // Wings
  const wingGeo = new THREE.PlaneGeometry(0.3, 0.2);
  
  const leftWing = new THREE.Mesh(
    wingGeo,
    new THREE.MeshStandardMaterial({ color: 0x222222, side: THREE.DoubleSide })
  );
  leftWing.position.set(0, 0, 0.15);
  leftWing.rotation.y = Math.PI / 4;
  group.add(leftWing);
  
  const rightWing = new THREE.Mesh(
    wingGeo,
    new THREE.MeshStandardMaterial({ color: 0x222222, side: THREE.DoubleSide })
  );
  rightWing.position.set(0, 0, -0.15);
  rightWing.rotation.y = -Math.PI / 4;
  group.add(rightWing);
  
  // Bird properties
  const bird = {
    obj: group,
    perched: false,
    flying: false,
    targetPosition: null,
    span: null,
    spanPoint: null,
    spanOffset: null,
    wingDirection: 1,
    wingAngle: 0,
    lookDirection: new THREE.Vector3(1, 0, 0),
    update: function(delta) {
      if (this.flying) {
        this.updateFlying(delta);
      } else if (this.perched) {
        this.updatePerched(delta);
      } else {
        this.findPerch();
      }
    },
    updateFlying: function(delta) {
      if (!this.targetPosition) {
        this.findPerch();
        return;
      }

      // Move toward target
      const moveSpeed = birdSettings.flySpeed * delta;
      const direction = new THREE.Vector3().subVectors(this.targetPosition, this.obj.position).normalize();
      this.obj.position.add(direction.multiplyScalar(moveSpeed));
      this.lookDirection.lerp(direction, 0.1);
      
      // Set bird orientation
      this.obj.lookAt(this.obj.position.clone().add(this.lookDirection));
      
      // Flap wings
      this.wingAngle += birdSettings.wingSpeed * this.wingDirection;
      if (Math.abs(this.wingAngle) >= 0.5) {
        this.wingDirection *= -1;
      }
      
      this.obj.children[2].rotation.z = this.wingAngle; // Left wing
      this.obj.children[3].rotation.z = -this.wingAngle; // Right wing
      
      // Check if we've reached the target
      if (this.obj.position.distanceTo(this.targetPosition) < 0.2) {
        if (this.span) {
          this.perched = true;
          this.flying = false;
          this.wingAngle = 0;
          this.obj.children[2].rotation.z = 0;
          this.obj.children[3].rotation.z = 0;
        } else {
          this.findPerch();
        }
      }
    },
    updatePerched: function() {
      // Occasionally look around or adjust position
      if (Math.random() < 0.005) {
        this.obj.rotation.y += (Math.random() - 0.5) * 0.2;
      }
      
      // If the span is removed, fly away
      if (!scene.children.includes(this.span)) {
        this.flyAway();
      }
    },
    findPerch: function() {
      const spans = scene.children.filter(o => o.userData.span);
      if (spans.length === 0) {
        this.flyAway();
        return;
      }
      
      // Pick a random span
      const span = spans[Math.floor(Math.random() * spans.length)];
      
      // Pick a random point along the span
      const positions = span.geometry.attributes.position;
      const pointIndex = Math.floor(Math.random() * (positions.count - 2) + 1);
      
      // Get the position on the span
      const point = new THREE.Vector3(
        positions.getX(pointIndex),
        positions.getY(pointIndex) + birdSettings.perchHeight,
        positions.getZ(pointIndex)
      );
      
      this.span = span;
      this.targetPosition = point;
      this.spanPoint = pointIndex;
      this.spanOffset = birdSettings.perchHeight;
      
      // If not already flying, start flying
      if (!this.flying) {
        this.flying = true;
        this.perched = false;
        
        // If bird isn't in the scene yet, position it randomly above
        if (!scene.children.includes(this.obj)) {
          const randomPos = new THREE.Vector3(
            point.x + (Math.random() - 0.5) * 20,
            point.y + 10 + Math.random() * 10,
            point.z + (Math.random() - 0.5) * 20
          );
          this.obj.position.copy(randomPos);
          scene.add(this.obj);
        }
        
        // Look toward the target
        this.lookDirection = new THREE.Vector3().subVectors(this.targetPosition, this.obj.position).normalize();
      }
    },
    flyAway: function() {
      this.span = null;
      this.perched = false;
      this.flying = true;
      
      // Fly up and slightly away
      const flyDirection = new THREE.Vector3(
        (Math.random() - 0.5) * 2,
        1,
        (Math.random() - 0.5) * 2
      ).normalize();
      
      this.targetPosition = new THREE.Vector3().addVectors(
        this.obj.position,
        flyDirection.multiplyScalar(15)
      );
      
      // After flying away, try to find a new perch
      setTimeout(() => {
        if (this.obj && scene.children.includes(this.obj)) {
          this.findPerch();
        }
      }, 2000 + Math.random() * 3000);
    }
  };
  
  return bird;
}

function initBirds() {
  birds.forEach(bird => {
    if (bird.obj && scene.children.includes(bird.obj)) {
      scene.remove(bird.obj);
    }
  });
  birds.length = 0;
  
  const spans = scene.children.filter(o => o.userData.span);
  if (spans.length === 0) return;
  
  for (let i = 0; i < birdSettings.count; i++) {
    if (Math.random() < birdSettings.spawnChance) {
      const bird = createBird();
      
      // Set bird color based on environment
      if (environmentSel && environmentSel.value === 'coastal') {
        bird.obj.children.forEach(part => {
          if (part.isMesh) {
            part.material.color.setHex(0xffffff);
          }
        });
      }
      
      birds.push(bird);
      
      setTimeout(() => {
        bird.findPerch();
      }, i * 500);
    }
  }
}

(function loop(){ 
  requestAnimationFrame(loop); 
  controls.update();
  
  // Update grid labels position if they exist
  scene.children.filter(o => o.userData.grid && o.userData.labels).forEach(grid => {
    if (grid.userData.labels && grid.visible) {
      grid.userData.labels.forEach(label => {
        const screenPosition = label.position.clone();
        screenPosition.project(camera);
        
        const x = (screenPosition.x * 0.5 + 0.5) * innerWidth;
        const y = (-(screenPosition.y * 0.5) + 0.5) * innerHeight;
        
        if (screenPosition.z < 1) {
          label.element.style.display = 'block';
          label.element.style.transform = `translate(-50%, -50%)`;
          label.element.style.left = `${x}px`;
          label.element.style.top = `${y}px`;
        } else {
          label.element.style.display = 'none';
        }
      });
    } else if (grid.userData.labels) {
      grid.userData.labels.forEach(label => {
        label.element.style.display = 'none';
      });
    }
  });
  
  // Update birds
  const delta = 0.016; // Approximate frame time
  birds.forEach(bird => bird.update(delta));
  
  // Update coastal water waves if present
  const waterMesh = scene.children.find(o => o.userData.isWater);
  if (waterMesh && waterMesh.userData.waveInfo) {
    const waveInfo = waterMesh.userData.waveInfo;
    waveInfo.time += delta * 0.5;
    
    // Animate water vertices to create gentle waves
    const positions = waterMesh.geometry.attributes.position;
    const originalPos = waveInfo.originalPositions;
    
    for (let i = 0; i < positions.count; i++) {
      const orig = originalPos[i];
      
      // Get position relative to shoreline for wave intensity
      const distFromShore = orig.x + 40; // Assuming shoreline is at x = -40
      const waveMultiplier = Math.min(1, Math.max(0, distFromShore / 60)); // Stronger waves further from shore
      
      // Create gentle wave motion
      // More intense near shore with direction toward shore
      const wavePhase = waveInfo.time + orig.z * 0.05;
      const waveHeight = 0.2 * waveMultiplier * Math.sin(wavePhase);
      
      // Additional smaller ripples
      const ripplePhase1 = waveInfo.time * 1.2 + orig.x * 0.1;
      const ripplePhase2 = waveInfo.time * 0.8 - orig.z * 0.08;
      const rippleHeight = 0.05 * Math.sin(ripplePhase1) * Math.sin(ripplePhase2);
      
      positions.setY(i, orig.y + waveHeight + rippleHeight);
    }
    
    positions.needsUpdate = true;
    
    // Animate foam at shoreline
    const foam = scene.children.find(o => o.userData.isWaterFoam);
    if (foam) {
      // Make foam move slightly up and down with waves
      const foamHeight = 0.12 + 0.05 * Math.sin(waveInfo.time * 1.2);
      foam.position.y = foamHeight;
      
      // Vary foam opacity with wave motion
      const foamOpacity = 0.6 + 0.2 * Math.sin(waveInfo.time);
      foam.material.opacity = foamOpacity;
    }
  }
  
  renderer.render(scene,camera);
})();


</script>
</body>
</html>
