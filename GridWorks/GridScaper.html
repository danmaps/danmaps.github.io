<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GridScaper Prototype — Span-to-Span Clearance</title>
  <style>
    html,body,#c{margin:0;height:100%;overflow:hidden;font-family:sans-serif}
    #hud{position:fixed;top:8px;left:8px;background:#0008;color:#fff;padding:6px 10px;font-size:12px;line-height:1.4;border-radius:6px;user-select:none}
    #hud input[type="range"],#hud select{vertical-align:middle}
    #hud label{margin-right:4px}
    #jsonPanel{
      position: absolute;
      top: 0;
      right: 0;
      width: 310px;
      margin: 8px;
      background-color: #1a1a1a;
      color: #efefef;
      font-family: 'Lucida Grande', sans-serif;
      font-size: 11px;
      border-radius: 6px;
      overflow: hidden;
      z-index: 1000;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    }
    .panel-title {
      padding: 8px;
      background: #323232;
      color: #efefef;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #2c2c2c;
    }
    .panel-title:hover {
      background: #3a3a3a;
    }
    .panel-content {
      max-height: calc(100vh - 120px);
      overflow: auto;
    }
    .panel-folder {
      margin-bottom: 4px;
      border-bottom: 1px solid #2c2c2c;
    }
    .panel-folder-title {
      padding: 8px;
      cursor: pointer;
      background-color: #262626;
      display: flex;
      justify-content: space-between;
    }
    .panel-folder-title:hover {
      background-color: #2f2f2f;
    }
    .panel-folder-content {
      padding: 8px;
      overflow: hidden;
      transition: height 0.3s ease;
      background-color: #1a1a1a;
    }
    .folder-collapsed .panel-folder-content {
      height: 0 !important;
      padding: 0;
    }
    .json-key { color: #9cdcfe; }
    .json-string { color: #ce9178; }
    .json-number { color: #b5cea8; }
    .json-boolean { color: #569cd6; }
    .json-null { color: #777777; }
    .json-row {
      padding: 4px 8px;
      display: flex;
      justify-content: space-between;
    }
    .json-row:nth-child(odd) {
      background-color: #222222;
    }
    .json-value {
      text-align: right;
    }
  </style>
  <script src="https://unpkg.com/three@0.139.2/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.139.2/examples/js/controls/OrbitControls.js"></script>
  <script type="module" src="json-view.js"></script>
</head>
<body>
  <div id="hud">
    <div><strong>Left-click</strong>: add pole • <strong>Right-click</strong>: delete pole/tree • <strong>Drag pole</strong>: adjust height • <strong>Drag empty</strong>: orbit</div>
    <label>New pole height: <input id="heightSlider" type="range" min="1" max="40" step="1" value="20"></label>
    <span id="heightLabel">20</span> ft
    &nbsp;&nbsp;|&nbsp;&nbsp;
    <label>Terrain: <select id="terrainSelect"><option value="flat" selected>Flat</option><option value="hills">Rolling Hills</option><option value="hillsTrees">Hills + Trees</option></select></label>
    &nbsp;&nbsp;|&nbsp;&nbsp;
    <label>Tension: <input id="tensionSlider" type="range" min="0.2" max="5" step="0.1" value="1"></label>
    <span id="tensionLabel">1.0×</span>
    &nbsp;&nbsp;|&nbsp;&nbsp;
    <button id="downloadJSON">Download</button>
    <button id="clearScene">Clear Scene</button>
  </div>
  <canvas id="c"></canvas>
  </div>

<script>
/* ------- constants ------- */
const CLEARANCE = 1;          // ft span‑to‑span
const SAMPLES   = 32;         // points per span
const DRAG_SENS = 0.05;       // ft per pixel when dragging pole
const MINH = 1, MAXH = 40;
const SNAP = v=>Math.round(v);

/* ------- UI refs ------- */
const slider = document.getElementById('heightSlider');
const hLabel = document.getElementById('heightLabel');
const terrainSel = document.getElementById('terrainSelect');
const tensionSlider = document.getElementById('tensionSlider');
const tensionLabel = document.getElementById('tensionLabel');
let currentH = +slider.value;
let currentTension = +tensionSlider.value;
slider.oninput = ()=>{ currentH=+slider.value; hLabel.textContent=currentH; updateGhost(); };
terrainSel.onchange = ()=>{ buildTerrain(); resetScene(); };
tensionSlider.oninput = ()=>{ currentTension=+tensionSlider.value; tensionLabel.textContent=currentTension.toFixed(1)+'×'; rebuild(); };

/* ------- three basics ------- */
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas,antialias:true});
renderer.setSize(innerWidth,innerHeight);
const scene = new THREE.Scene(); scene.background=new THREE.Color(0x87ceeb);
const camera = new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,1000);
camera.position.set(40,40,40);
const controls = new THREE.OrbitControls(camera,renderer.domElement); controls.enableDamping=true;
scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));
const sun = new THREE.DirectionalLight(0xffffff,0.6); sun.position.set(10,40,20); scene.add(sun);

/* ------- terrain & trees ------- */
const SIZE=120, SEG=120;

const urlParams = new URLSearchParams(window.location.search);

// Parse pole parameters from URL and normalize if needed
const poleDistances = urlParams.get('poles-distances')?.split(',').map(Number).filter(v => !isNaN(v)) || [];
const poleHeights = urlParams.get('poles-heights')?.split(',').map(Number).filter(v => !isNaN(v)) || [];
const poleElevations = urlParams.get('poles-elevations')?.split(',').map(Number).filter(v => !isNaN(v)) || [];

// Create default elevations (zeros) if distances and heights exist but elevations are missing
let useElevations = poleElevations;
if (poleDistances.length > 0 && poleHeights.length > 0 && poleElevations.length === 0) {
  useElevations = Array(Math.min(poleDistances.length, poleHeights.length)).fill(0);
}

// Parse URL parameters for grid dimensions
const sizeX = Math.max(parseInt(urlParams.get('size-x')) || SIZE, Math.max(...poleDistances) + 20);
const sizeY = Math.max(parseInt(urlParams.get('size-y')) || SIZE, Math.max(...poleDistances) + 20);

let customPoles = null;
if (poleDistances.length && poleHeights.length && 
    poleDistances.length === poleHeights.length && 
    poleDistances.length === useElevations.length) {

  // Interpolate and scale values for large inputs
  const normalizeDistances = () => {
    const maxDistance = Math.max(...poleDistances);
    const minDistance = Math.min(...poleDistances);
    const range = maxDistance - minDistance;
    
    // Scale distances to fit within a reasonable view if too large
    let scaledDistances = [...poleDistances];
    let scaling = false;
    
    if (range > 100) {
      scaling = true;
      const targetRange = 50;
      const scaleFactor = targetRange / range;
      scaledDistances = poleDistances.map(d => minDistance + (d - minDistance) * scaleFactor);
      console.log(`Scaling distances: Original range ${range} → ${targetRange} units (scale factor: ${scaleFactor.toFixed(2)})`);
    }
    
    return { distances: scaledDistances, scaling };
  };
  
  const normalizeHeights = () => {
    const maxHeight = Math.max(...poleHeights);
    let scaledHeights = [...poleHeights];
    let scaling = false;
    
    if (maxHeight > 40) {
      scaling = true;
      const scaleFactor = 35 / maxHeight; // Scale to reasonable max height
      scaledHeights = poleHeights.map(h => h * scaleFactor);
      console.log(`Scaling heights: Max height ${maxHeight} → 35 units (scale factor: ${scaleFactor.toFixed(2)})`);
    }
    
    return { heights: scaledHeights, scaling };
  };
  
  const normalizeElevations = () => {
    const maxElev = Math.max(...useElevations);
    const minElev = Math.min(...useElevations);
    const range = maxElev - minElev;
    let scaledElevations = [...useElevations];
    let scaling = false;
    
    if (range > 30) {
      scaling = true;
      const targetRange = 20;
      const scaleFactor = targetRange / range;
      scaledElevations = useElevations.map(e => minElev + (e - minElev) * scaleFactor);
      console.log(`Scaling elevations: Original range ${range} → ${targetRange} units (scale factor: ${scaleFactor.toFixed(2)})`);
    }
    
    return { elevations: scaledElevations, scaling };
  };

  // Apply normalizations
  const { distances, scaling: distScaling } = normalizeDistances();
  const { heights, scaling: heightScaling } = normalizeHeights();
  const { elevations, scaling: elevScaling } = normalizeElevations();
  
  if (distScaling || heightScaling || elevScaling) {
    console.log("Normalized parameters for better visualization while preserving relative proportions");
  } else {
    console.log("Using original pole parameters (no scaling needed)");
  }

  customPoles = distances.map((x, i) => ({ x, h: heights[i], elev: elevations[i] }));
}

// Define the base height calculation function
function calculateTerrainHeight(x, z) {
  return terrainSel.value === 'flat' ? 0 : Math.sin(x*0.09)*5 + Math.cos(z*0.11)*3 + Math.sin((x+z)*0.04)*2;
}

// Custom ground function for sloped surface through pole elevations
let customGround = null;
if (customPoles) {
  customGround = (x, z) => {
    // Convert worldZ to local coordinate system
    const localZ = z - terrainOffsetZ;
    
    // Direct pole base elevation lookup
    if (localZ <= customPoles[0].x) return customPoles[0].elev;
    if (localZ >= customPoles[customPoles.length-1].x) return customPoles[customPoles.length-1].elev;
    
    // Linear interpolation between pole elevations with precise positioning
    for (let i = 1; i < customPoles.length; i++) {
      if (localZ < customPoles[i].x) {
        const t = (localZ - customPoles[i-1].x) / (customPoles[i].x - customPoles[i-1].x);
        return customPoles[i-1].elev * (1-t) + customPoles[i].elev * t;
      }
    }
    return customPoles[customPoles.length-1].elev;
  };
}

// Height at specific location function
function hAt(x, z) {
  if (customGround) {
    return customGround(x, z);
  }
  return calculateTerrainHeight(x, z);
}

let terrain=null; const trees=new THREE.Group(); scene.add(trees); const treeData=[]; // {x,z,yTop,ref}
let terrainOffsetZ = 0;

// Add grid lines and labels
function addGridLines() {
  // Remove any existing grid
  scene.children.filter(o => o.userData.grid).forEach(g => {
    scene.remove(g);
    if (g.geometry) g.geometry.dispose();
  });
  
  const gridGroup = new THREE.Group();
  gridGroup.userData.grid = true;
  
  const gridMaterial = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });
  
  // Create grid lines at 50-foot intervals
  for (let i = -SIZE / 2; i <= SIZE / 2; i += 50) {
    // X-axis lines (along Z)
    const geometryX = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(i, 0.05, -SIZE / 2),
      new THREE.Vector3(i, 0.05, SIZE / 2)
    ]);
    const lineX = new THREE.Line(geometryX, gridMaterial);
    gridGroup.add(lineX);
    
    // Z-axis lines (along X)
    const geometryZ = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-SIZE / 2, 0.05, i),
      new THREE.Vector3(SIZE / 2, 0.05, i)
    ]);
    const lineZ = new THREE.Line(geometryZ, gridMaterial);
    gridGroup.add(lineZ);
    
    // Skip label at origin (0,0)
    if (i !== 0) {
      // Create label for X coordinate
      const labelX = document.createElement('div');
      labelX.className = 'grid-label';
      labelX.textContent = `${i}`;
      labelX.style.position = 'absolute';
      labelX.style.color = 'black';
      labelX.style.backgroundColor = 'rgba(255,255,255,0.5)';
      labelX.style.padding = '2px 4px';
      labelX.style.borderRadius = '2px';
      labelX.style.fontSize = '10px';
      labelX.style.userSelect = 'none';
      labelX.style.pointerEvents = 'none';
      document.body.appendChild(labelX);
      
      const labelPoints = new THREE.Vector3(i, 0.1, -SIZE / 2 + 5);
      gridGroup.userData.labels = gridGroup.userData.labels || [];
      gridGroup.userData.labels.push({
        element: labelX,
        position: labelPoints,
        axis: 'x'
      });
      
      // Create label for Z coordinate
      const labelZ = document.createElement('div');
      labelZ.className = 'grid-label';
      labelZ.textContent = `${i}`;
      labelZ.style.position = 'absolute';
      labelZ.style.color = 'black';
      labelZ.style.backgroundColor = 'rgba(255,255,255,0.5)';
      labelZ.style.padding = '2px 4px';
      labelZ.style.borderRadius = '2px';
      labelZ.style.fontSize = '10px';
      labelZ.style.userSelect = 'none';
      labelZ.style.pointerEvents = 'none';
      document.body.appendChild(labelZ);
      
      const labelZPoints = new THREE.Vector3(-SIZE / 2 + 5, 0.1, i);
      gridGroup.userData.labels.push({
        element: labelZ,
        position: labelZPoints,
        axis: 'z'
      });
    }
  }
  
  scene.add(gridGroup);
}

function buildTerrain() {
  if (terrain) {
    scene.remove(terrain);
    terrain.geometry.dispose();
  }
  trees.clear();
  treeData.length = 0;

  let terrainWidth = 50;
  let terrainDepth = 100;

  if (customPoles && customPoles.length > 0) {
    const minZ = Math.min(...customPoles.map(p => p.x)) - 20;
    const maxZ = Math.max(...customPoles.map(p => p.x)) + 20;
    terrainDepth = maxZ - minZ;
    terrainOffsetZ = (minZ + maxZ) / 2;
  }

  // Create flat geometry
  const g = new THREE.PlaneGeometry(terrainWidth, terrainDepth, SEG, SEG);
  g.rotateX(-Math.PI / 2);

  // Create mesh with flat geometry
  terrain = new THREE.Mesh(g, new THREE.MeshStandardMaterial({ color: 0x5ca55c }));
  terrain.position.z = terrainOffsetZ;
  scene.add(terrain);
  
  // Deform vertices to match pole elevations
  const positions = terrain.geometry.attributes.position;
  for (let i = 0; i < positions.count; i++) {
    const x = positions.getX(i);
    // Convert from local space to world space for height lookup
    const localZ = positions.getZ(i);
    const worldZ = localZ + terrainOffsetZ;
    
    // Get height at this position
    let elevation = 0;
    if (customGround) {
      elevation = customGround(x, worldZ);
    } else {
      elevation = calculateTerrainHeight(x, worldZ);
    }
    
    positions.setY(i, elevation);
  }
  
  positions.needsUpdate = true;
  terrain.geometry.computeVertexNormals();
  
  // Add grid lines at 50-foot intervals
  addGridLines();
  
  if (terrainSel.value === 'hillsTrees') addTrees();
}

function addTrees(){
  const trunkG=new THREE.CylinderGeometry(0.15,0.15,1,6);
  const folG=new THREE.ConeGeometry(0.75,2,8);
  const trunkM=new THREE.MeshStandardMaterial({color:0x8b5a2b});
  const folM=new THREE.MeshStandardMaterial({color:0x2e8b57});
  const cluster=20,radius=6;
  for(let cx=-SIZE/2;cx<=SIZE/2;cx+=cluster){
    for(let cz=-SIZE/2;cz<=SIZE/2;cz+=cluster){ if(Math.random()<0.35){
      const n=THREE.MathUtils.randInt(6,15);
      for(let i=0;i<n;i++){
        const ang=Math.random()*Math.PI*2, r=Math.random()*radius;
        const x=cx+Math.cos(ang)*r, z=cz+Math.sin(ang)*r, y=hAt(x,z); const s=THREE.MathUtils.randFloat(0.8,1.6);
        const trunk=new THREE.Mesh(trunkG,trunkM); trunk.scale.y=s; trunk.position.set(x,y+s*0.5,z);
        const fol=new THREE.Mesh(folG,folM); fol.scale.setScalar(s); fol.position.set(x,y+s*1.5,z);
        const t=new THREE.Group(); t.add(trunk); t.add(fol); t.userData.tree=true; trees.add(t);
        treeData.push({x,z,yTop:y+s*1.5,ref:t});
      } }} }
}
buildTerrain();

/* ------- materials ------- */
const BASE_H=10, R=0.2;
const poleGeo = new THREE.CylinderGeometry(R,R,BASE_H,8);
const mPole   = new THREE.MeshStandardMaterial({color:0x8b5a2b});
const mPoleHL = new THREE.MeshStandardMaterial({color:0xffe66d});
const mGood   = new THREE.LineBasicMaterial({color:0x000000});
const mBad    = new THREE.LineBasicMaterial({color:0xff0000});
const mGhost  = new THREE.MeshStandardMaterial({color:0x46c9ff,transparent:true,opacity:0.4});
const mTreeHL = new THREE.MeshStandardMaterial({color:0xffff8d});
const mGrid   = new THREE.LineBasicMaterial({color:0x555555, transparent:true, opacity:0.5});

/* ------- data stores ------- */
const poles=[]; // {x,z,h,base,obj}
const ray=new THREE.Raycaster(); const mouse=new THREE.Vector2();

/* ------- span build & check ------- */
function violates(samples,aObj,bObj){
  for(const v of samples){
    if(v.y<=hAt(v.x,v.z)+0.1) return true; // ground
    for(const t of treeData){ if(Math.hypot(v.x-t.x,v.z-t.z)<1 && v.y<=t.yTop) return true; }
    for(const p of poles){ if(p.obj===aObj||p.obj===bObj) continue; if(Math.hypot(v.x-p.x,v.z-p.z)<R+0.1 && v.y<=p.base+p.h) return true; }
  }
  const others=scene.children.filter(l=>l.userData.span&&![aObj,bObj].includes(l.userData.a)&&![aObj,bObj].includes(l.userData.b));
  for(const o of others){ const pos=o.geometry.attributes.position; for(let i=0;i<pos.count;i+=4){ const q=new THREE.Vector3(pos.getX(i),pos.getY(i),pos.getZ(i)); for(const v of samples){ if(v.distanceTo(q)<CLEARANCE) return true; } } }
  return false;
}
function drawSpan(a,b){
  const yA=a.base+a.h, yB=b.base+b.h; 
  const d=Math.hypot(b.x-a.x,b.z-a.z); 
  const sag=Math.max(0.1,d*0.05) / currentTension;
  const pts=[]; 
  for(let i=0;i<=SAMPLES;i++){
    const t=i/SAMPLES; 
    const x=THREE.MathUtils.lerp(a.x,b.x,t); 
    const z=THREE.MathUtils.lerp(a.z,b.z,t); 
    const y=THREE.MathUtils.lerp(yA,yB,t)-sag*Math.sin(Math.PI*t); 
    pts.push(new THREE.Vector3(x,y,z));
  }
  const bad=violates(pts,a.obj,b.obj);
  const geo=new THREE.BufferGeometry().setFromPoints(pts);
  const line=new THREE.Line(geo,bad?mBad:mGood); 
  line.userData={span:true,a:a.obj,b:b.obj}; 
  scene.add(line);
}
function rebuild(){ scene.children.filter(o=>o.userData.span).forEach(l=>{l.geometry.dispose();scene.remove(l);}); for(let i=1;i<poles.length;i++) drawSpan(poles[i-1],poles[i]); }

/* ------- pole helpers ------- */
function addPole(x,z,h) {
  if(poles.some(p=>p.x===x && p.z===z)) return; 
  const base = hAt(x,z + terrainOffsetZ); 
  const mesh = new THREE.Mesh(poleGeo,mPole); 
  mesh.scale.y = h/BASE_H; 
  mesh.position.set(x, base + h/2, z);
  mesh.userData.pole = true; 
  scene.add(mesh); 
  poles.push({x, z, h, base, obj:mesh}); 
  rebuild();
}
function removePole(obj){ const i=poles.findIndex(p=>p.obj===obj); if(i>-1){scene.remove(obj); poles.splice(i,1); rebuild();}}

/* ------- ghost pole ------- */
let ghost=new THREE.Mesh(poleGeo,mGhost); ghost.visible=false; scene.add(ghost);
let hoverPt=null, hoverPole=null, hoverTree=null;

// Adjust terrain alignment and raycasting logic
function updateGhost() {
  ghost.visible = false;
  if (!hoverPt || hoverPole || hoverTree) return;
  if (poles.some(p => p.x === hoverPt.x && p.z === hoverPt.z)) return;

  const h = currentH;
  const base = hAt(hoverPt.x, hoverPt.z + terrainOffsetZ);

  ghost.scale.y = h / BASE_H;
  ghost.position.set(hoverPt.x, base + h / 2, hoverPt.z);
  ghost.visible = true;
}

/* ------- picking helpers ------- */
function pick(evt,list){ mouse.set((evt.clientX/innerWidth)*2-1,-(evt.clientY/innerHeight)*2+1); ray.setFromCamera(mouse,camera); return ray.intersectObjects(list,true)[0]?.object||null; }
const poleMeshes=()=>poles.map(p=>p.obj);
function setTreeHL(t,on){ t.traverse(m=>{if(m.isMesh)m.material=on?mTreeHL:(m.geometry.type==='CylinderGeometry'?new THREE.MeshStandardMaterial({color:0x8b5a2b}):new THREE.MeshStandardMaterial({color:0x2e8b57}));}); }

/* ------- interaction state ------- */
let drag=null,startY=0,startH=0,clickStart=null;

window.addEventListener('contextmenu', e => {
  e.preventDefault(); // Prevent the default context menu
  const tPick = pick(e, trees.children);
  if (tPick) {
    trees.remove(tPick);
    treeData.splice(treeData.findIndex(t => t.ref === tPick), 1);
    rebuild();
    return;
  }
  
  const pPick = pick(e, poleMeshes());
  if (pPick) {
    removePole(pPick);
    return;
  }
});

window.addEventListener('pointermove', e => {
  const pPick = pick(e, poleMeshes());
  if (pPick !== hoverPole) {
    if (hoverPole) hoverPole.material = mPole;
    hoverPole = pPick;
    if (hoverPole) hoverPole.material = mPoleHL;
  }

  const tPick = pick(e, trees.children);
  if (tPick !== hoverTree) {
    if (hoverTree) setTreeHL(hoverTree, false);
    hoverTree = tPick;
    if (hoverTree) setTreeHL(hoverTree, true);
  }

  mouse.set((e.clientX / innerWidth) * 2 - 1, -(e.clientY / innerHeight) * 2 + 1);
  ray.setFromCamera(mouse, camera);
  const hit = ray.intersectObject(terrain, true)[0];

  if (hit) {
    hoverPt = {
      x: SNAP(hit.point.x),
      z: SNAP(hit.point.z - terrainOffsetZ),
    };
  } else {
    hoverPt = null;
  }

  updateGhost();
});

window.addEventListener('pointerdown', e => {
  if (e.shiftKey) {
    // Do nothing for Shift+click
    return;
  }

  const pPick = pick(e, poleMeshes());
  if (pPick) {
    drag = pPick;
    startY = e.clientY;
    startH = poles.find(p => p.obj === drag).h;
    controls.enabled = false;
    return;
  }
  clickStart = [e.clientX, e.clientY];
});

window.addEventListener('pointerup', e => {
  if (drag) {
    drag = null;
    controls.enabled = true;
    return;
  }
  if (!clickStart) return;
  const [dx, dy] = [Math.abs(e.clientX - clickStart[0]), Math.abs(e.clientY - clickStart[1])];
  clickStart = null;
  if (dx < 5 && dy < 5 && hoverPt) {
    const h = currentH;
    const base = hAt(hoverPt.x, hoverPt.z + terrainOffsetZ);
    addPole(hoverPt.x, hoverPt.z, h);
    updateGhost();
  }
});

function resetScene(){ poles.forEach(p=>scene.remove(p.obj)); poles.length=0; scene.children.filter(o=>o.userData.span).forEach(l=>{l.geometry.dispose();scene.remove(l);}); updateGhost();}

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* ------- geometric calculations ------- */
function round2(value) {
  return value === null ? null : parseFloat(value.toFixed(2));
}

function calculateDistance(p1, p2) {
  return Math.hypot(p2.x - p1.x, p2.z - p1.z);
}

function calculateAngle(p1, p2) {
  return Math.atan2(p2.z - p1.z, p2.x - p1.x) * (180 / Math.PI);
}

function calculateInclinationAngle(p1, p2) {
  const dx = p2.x - p1.x;
  const dz = p2.z - p1.z;
  const dy = (p2.base + p2.h) - (p1.base + p1.h);
  const horizontalDistance = Math.hypot(dx, dz);
  
  return Math.atan2(dy, horizontalDistance) * (180 / Math.PI);
}

function calculateCatenaryAngles(p1, p2, tensionFactor) {
  const horizontalDistance = calculateDistance(p1, p2);
  if (horizontalDistance === 0) return { departureAngle: 0, arrivalAngle: 0 };
  
  const height1 = p1.base + p1.h;
  const height2 = p2.base + p2.h;
  const heightDiff = height2 - height1;
  
  const sag = Math.max(0.1, horizontalDistance * 0.05) / tensionFactor;
  
  const baseSlopeAngle = Math.atan2(heightDiff, horizontalDistance);
  const sagEffect = Math.atan(Math.PI * sag / horizontalDistance);
  
  const departureAngle = (baseSlopeAngle + sagEffect) * (180 / Math.PI);
  const arrivalAngle = (baseSlopeAngle - sagEffect) * (180 / Math.PI);
  
  return { departureAngle, arrivalAngle };
}

function calculateSpanLength(p1, p2, sag) {
  const distance = calculateDistance(p1, p2);
  if (distance === 0) return 0;
  
  // Approximate the conductor length with discrete integration over catenary curve
  const segments = 50;
  let length = 0;
  const height1 = p1.base + p1.h;
  const height2 = p2.base + p2.h;
  
  for (let i = 0; i < segments; i++) {
    const t1 = i / segments;
    const t2 = (i + 1) / segments;
    
    const x1 = p1.x + (p2.x - p1.x) * t1;
    const z1 = p1.z + (p2.z - p1.z) * t1;
    const y1 = height1 + (height2 - height1) * t1 - sag * Math.sin(Math.PI * t1);
    
    const x2 = p1.x + (p2.x - p1.x) * t2;
    const z2 = p1.z + (p2.z - p1.z) * t2;
    const y2 = height1 + (height2 - height1) * t2 - sag * Math.sin(Math.PI * t2);
    
    length += Math.hypot(x2 - x1, y2 - y1, z2 - z1);
  }
  
  return length;
}

function calculateTopAngle(p1, p2, p3) {
  const angle1 = calculateAngle(p2, p1);
  const angle2 = calculateAngle(p2, p3);
  
  let diff = Math.abs(angle2 - angle1);
  if (diff > 180) diff = 360 - diff;
  
  return diff;
}


function collectData() {
  const polesData = poles.map((p, index) => {
    const nextPole = index < poles.length - 1 ? poles[index + 1] : null;
    const prevPole = index > 0 ? poles[index - 1] : null;
    
    const distanceToNext = nextPole ? calculateDistance(p, nextPole) : 0;
    const sag = nextPole ? Math.max(0.1, distanceToNext * 0.05) / currentTension : 0;
    
    let departureAngle = null;
    let arrivalAngle = null;
    
    if (nextPole) {
      const angles = calculateCatenaryAngles(p, nextPole, currentTension);
      departureAngle = angles.departureAngle;
    }
    
    if (prevPole) {
      const angles = calculateCatenaryAngles(prevPole, p, currentTension);
      arrivalAngle = angles.arrivalAngle;
    }
    
    const topAngle = (prevPole && nextPole) ? calculateTopAngle(prevPole, p, nextPole) : null;
    
    return {
      id: index + 1,
      x: round2(p.x),
      z: round2(p.z),
      height: round2(p.h),
      baseElevation: round2(p.base),
      nextPoleId: nextPole ? index + 2 : null,
      distanceToNext: round2(distanceToNext),
      arrivalAngle: round2(arrivalAngle),
      departureAngle: round2(departureAngle),
      topAngle: round2(topAngle)
    };
  });
  
  const spansData = [];
  for (let i = 0; i < poles.length - 1; i++) {
    const a = poles[i];
    const b = poles[i + 1];
    const distance = calculateDistance(a, b);
    const sag = Math.max(0.1, distance * 0.05) / currentTension;
    const angles = calculateCatenaryAngles(a, b, currentTension);
    const straightLineSlope = calculateInclinationAngle(a, b);
    
    const span = scene.children.find(o => 
      o.userData.span && 
      o.userData.a === a.obj && 
      o.userData.b === b.obj
    );
    
    spansData.push({
      fromPoleId: i + 1,
      toPoleId: i + 2,
      distance: round2(distance),
      length: round2(calculateSpanLength(a, b, sag)),
      departureAngle: round2(angles.departureAngle),
      arrivalAngle: round2(angles.arrivalAngle),
      sagDistance: round2(sag),
      straightLineSlope: round2(straightLineSlope),
      valid: span ? span.material === mGood : false
    });
  }
  
  return {
    poles: polesData,
    spans: spansData,
    terrain: terrainSel.value,
    tensionMultiplier: currentTension
  };
}

// Place custom poles on load
if (customPoles) {
  poles.length = 0;
  for (const pole of customPoles) {
    const mesh = new THREE.Mesh(poleGeo, mPole);
    mesh.scale.y = pole.h / BASE_H;
    
    const zPos = pole.x;
    const base = pole.elev;
    
    mesh.position.set(0, base + pole.h / 2, zPos);
    mesh.userData.pole = true;
    scene.add(mesh);
    poles.push({ x: 0, z: zPos, h: pole.h, base, obj: mesh });
  }
  rebuild();
}

(function loop(){ 
  requestAnimationFrame(loop); 
  controls.update();
  
  // Update grid labels position if they exist
  scene.children.filter(o => o.userData.grid && o.userData.labels).forEach(grid => {
    if (grid.userData.labels) {
      grid.userData.labels.forEach(label => {
        const screenPosition = label.position.clone();
        screenPosition.project(camera);
        
        const x = (screenPosition.x * 0.5 + 0.5) * innerWidth;
        const y = (-(screenPosition.y * 0.5) + 0.5) * innerHeight;
        
        if (screenPosition.z < 1) {
          label.element.style.display = 'block';
          label.element.style.transform = `translate(-50%, -50%)`;
          label.element.style.left = `${x}px`;
          label.element.style.top = `${y}px`;
        } else {
          label.element.style.display = 'none';
        }
      });
    }
  });
  
  renderer.render(scene,camera);
})();


</script>
</body>
</html>
