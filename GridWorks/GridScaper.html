<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GridScaper Prototype — Span-to-Span Clearance</title>
  <style>
    html,body,#c{margin:0;height:100%;overflow:hidden;font-family:sans-serif}
    #hud{position:fixed;top:8px;left:8px;background:#0008;color:#fff;padding:6px 10px;font-size:12px;line-height:1.4;border-radius:6px;user-select:none}
    #hud input[type="range"],#hud select{vertical-align:middle}
    #hud label{margin-right:4px}
    #jsonPanel{
      position: absolute;
      top: 0;
      right: 0;
      width: 310px;
      margin: 8px;
      background-color: #1a1a1a;
      color: #efefef;
      font-family: 'Lucida Grande', sans-serif;
      font-size: 11px;
      border-radius: 6px;
      overflow: hidden;
      z-index: 1000;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    }
    .panel-title {
      padding: 8px;
      background: #323232;
      color: #efefef;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #2c2c2c;
    }
    .panel-title:hover {
      background: #3a3a3a;
    }
    .panel-content {
      max-height: calc(100vh - 120px);
      overflow: auto;
    }
    .panel-folder {
      margin-bottom: 4px;
      border-bottom: 1px solid #2c2c2c;
    }
    .panel-folder-title {
      padding: 8px;
      cursor: pointer;
      background-color: #262626;
      display: flex;
      justify-content: space-between;
    }
    .panel-folder-title:hover {
      background-color: #2f2f2f;
    }
    .panel-folder-content {
      padding: 8px;
      overflow: hidden;
      transition: height 0.3s ease;
      background-color: #1a1a1a;
    }
    .folder-collapsed .panel-folder-content {
      height: 0 !important;
      padding: 0;
    }
    .json-key { color: #9cdcfe; }
    .json-string { color: #ce9178; }
    .json-number { color: #b5cea8; }
    .json-boolean { color: #569cd6; }
    .json-null { color: #777777; }
    .json-row {
      padding: 4px 8px;
      display: flex;
      justify-content: space-between;
    }
    .json-row:nth-child(odd) {
      background-color: #222222;
    }
    .json-value {
      text-align: right;
    }
  </style>
  <script src="https://unpkg.com/three@0.139.2/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.139.2/examples/js/controls/OrbitControls.js"></script>
  <script type="module" src="json-view.js"></script>
</head>
<body>
  <div id="hud">
    <div><strong>Left-click</strong>: add pole • <strong>Right-click</strong>: delete pole</div>
    <label>New pole height: <input id="heightSlider" type="range" min="1" max="40" step="1" value="20"></label>
    <span id="heightLabel">20</span> ft
    &nbsp;&nbsp;|&nbsp;&nbsp;
    <label>Terrain: <select id="terrainSelect"><option value="flat" selected>Flat</option><option value="hills">Rolling Hills</option><option value="hillsTrees">Hills + Trees</option></select></label>
    &nbsp;&nbsp;|&nbsp;&nbsp;
    <label>Tension: <input id="tensionSlider" type="range" min="0.2" max="5" step="0.1" value="1"></label>
    <span id="tensionLabel">1.0×</span>
    &nbsp;&nbsp;|&nbsp;&nbsp;
    <button id="downloadJSON">Download</button>
    <button id="clearScene">Clear Scene</button>
  </div>
  <canvas id="c"></canvas>
  </div>

<script>
/* ------- constants ------- */
const CLEARANCE = 1;          // ft span‑to‑span
const SAMPLES   = 32;         // points per span
const DRAG_SENS = 0.05;       // ft per pixel when dragging pole
const MINH = 1, MAXH = 40;
const SNAP = v=>Math.round(v);

/* ------- UI refs ------- */
const slider = document.getElementById('heightSlider');
const hLabel = document.getElementById('heightLabel');
const terrainSel = document.getElementById('terrainSelect');
const tensionSlider = document.getElementById('tensionSlider');
const tensionLabel = document.getElementById('tensionLabel');
const clearBtn = document.getElementById('clearScene');
let currentH = +slider.value;
let currentTension = +tensionSlider.value;
slider.oninput = ()=>{ currentH=+slider.value; hLabel.textContent=currentH; updateGhost(); };
terrainSel.onchange = ()=>{ buildTerrain(); resetScene(); };
tensionSlider.oninput = ()=>{ currentTension=+tensionSlider.value; tensionLabel.textContent=currentTension.toFixed(1)+'×'; rebuild(); };
clearBtn.onclick = resetScene;

/* ------- three basics ------- */
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas,antialias:true});
renderer.setSize(innerWidth,innerHeight);
const scene = new THREE.Scene(); scene.background=new THREE.Color(0x87ceeb);
const camera = new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,1000);
camera.position.set(40,40,40);
const controls = new THREE.OrbitControls(camera,renderer.domElement); controls.enableDamping=true;
scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));
const sun = new THREE.DirectionalLight(0xffffff,0.6); sun.position.set(10,40,20); scene.add(sun);

/* ------- terrain & trees ------- */
const SIZE=120, SEG=120;

const urlParams = new URLSearchParams(window.location.search);

// Parse pole parameters from URL and normalize if needed
const poleDistances = urlParams.get('poles-distances')?.split(',').map(Number).filter(v => !isNaN(v)) || [];
const poleHeights = urlParams.get('poles-heights')?.split(',').map(Number).filter(v => !isNaN(v)) || [];
const poleElevations = urlParams.get('poles-elevations')?.split(',').map(Number).filter(v => !isNaN(v)) || [];

// Create default elevations (zeros) if distances and heights exist but elevations are missing
let useElevations = poleElevations;
if (poleDistances.length > 0 && poleHeights.length > 0 && poleElevations.length === 0) {
  useElevations = Array(Math.min(poleDistances.length, poleHeights.length)).fill(0);
}

// Parse URL parameters for grid dimensions
const sizeX = Math.max(parseInt(urlParams.get('size-x')) || SIZE, Math.max(...poleDistances) + 20);
const sizeY = Math.max(parseInt(urlParams.get('size-y')) || SIZE, Math.max(...poleDistances) + 20);

let customPoles = null;
if (poleDistances.length && poleHeights.length && 
    poleDistances.length === poleHeights.length && 
    poleDistances.length === useElevations.length) {

  // Maintain height-to-distance proportions during scaling
  const normalizeData = () => {
    const maxDistance = Math.max(...poleDistances);
    const minDistance = Math.min(...poleDistances);
    const distRange = maxDistance - minDistance;
    
    const maxHeight = Math.max(...poleHeights);
    const minHeight = Math.min(...poleHeights);
    const heightRange = maxHeight - minHeight;
    
    const maxElev = Math.max(...useElevations);
    const minElev = Math.min(...useElevations);
    const elevRange = maxElev - minElev;
    
    let scaledDistances = [...poleDistances];
    let scaledHeights = [...poleHeights];
    let scaledElevations = [...useElevations];
    let scaling = false;
    let heightToDistanceRatio = heightRange / Math.max(1, distRange);
    
    // Scale if any dimension is too large
    if (distRange > 100 || maxHeight > 40 || elevRange > 30) {
      scaling = true;
      
      // Scale distances if needed
      if (distRange > 100) {
        const targetDistRange = 50;
        const distScaleFactor = targetDistRange / distRange;
        scaledDistances = poleDistances.map(d => minDistance + (d - minDistance) * distScaleFactor);
        console.log(`Scaling distances: ${distRange}ft → ${targetDistRange}ft (factor: ${distScaleFactor.toFixed(2)})`);
        
        // Proportionally adjust heights based on distance scaling to maintain aspect ratio
        const targetHeightRange = heightRange * distScaleFactor;
        scaledHeights = poleHeights.map(h => (h - minHeight) * distScaleFactor + minHeight);
        console.log(`Proportionally adjusting heights to maintain ${heightToDistanceRatio.toFixed(2)} height-to-distance ratio`);
      } 
      // Independent height scaling if needed
      else if (maxHeight > 40) {
        const heightScaleFactor = 35 / maxHeight;
        scaledHeights = poleHeights.map(h => h * heightScaleFactor);
        console.log(`Scaling heights: max ${maxHeight}ft → 35ft (factor: ${heightScaleFactor.toFixed(2)})`);
      }
      
      // Scale elevations if needed
      if (elevRange > 30) {
        const targetElevRange = 20;
        const elevScaleFactor = targetElevRange / elevRange;
        scaledElevations = useElevations.map(e => minElev + (e - minElev) * elevScaleFactor);
        console.log(`Scaling elevations: range ${elevRange}ft → ${targetElevRange}ft (factor: ${elevScaleFactor.toFixed(2)})`);
      }
      
      console.log("Proportional scaling applied to maintain realistic simulation");
    }
    
    return { 
      distances: scaledDistances, 
      heights: scaledHeights, 
      elevations: scaledElevations,
      scaling 
    };
  };

  const { distances, heights, elevations, scaling } = normalizeData();
  
  if (!scaling) {
    console.log("Using original pole parameters (no scaling needed)");
  }

  customPoles = distances.map((x, i) => ({ x, h: heights[i], elev: elevations[i] }));
}

// Define the base height calculation function
function calculateTerrainHeight(x, z) {
  return terrainSel.value === 'flat' ? 0 : Math.sin(x*0.09)*5 + Math.cos(z*0.11)*3 + Math.sin((x+z)*0.04)*2;
}

// Custom ground function for sloped surface through pole elevations
let customGround = null;
if (customPoles) {
  customGround = (x, z) => {
    // Convert world Z to local coordinate system
    const localZ = z - terrainOffsetZ;
    
    // For points before the first pole or after the last pole
    if (localZ <= customPoles[0].x) return customPoles[0].elev;
    if (localZ >= customPoles[customPoles.length-1].x) return customPoles[customPoles.length-1].elev;
    
    // Find the two closest poles for interpolation
    for (let i = 1; i < customPoles.length; i++) {
      if (localZ <= customPoles[i].x) {
        const t = (localZ - customPoles[i-1].x) / (customPoles[i].x - customPoles[i-1].x);
        // Linear interpolation between pole elevations
        return customPoles[i-1].elev * (1-t) + customPoles[i].elev * t;
      }
    }
    
    // Fallback
    return 0;
  };
}

// Height at specific location function
function hAt(x, z) {
  if (customGround) {
    return customGround(x, z);
  }
  return calculateTerrainHeight(x, z);
}

let terrain=null; const trees=new THREE.Group(); scene.add(trees); const treeData=[]; // {x,z,yTop,ref}
let terrainOffsetZ = 0;

// Add grid lines and labels
function addGridLines() {
  // Remove any existing grid
  scene.children.filter(o => o.userData.grid).forEach(g => {
    scene.remove(g);
    if (g.geometry) g.geometry.dispose();
  });

  const gridGroup = new THREE.Group();
  gridGroup.userData.grid = true;

  const gridMaterial = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });

  // Create grid lines at 10-foot intervals
  for (let i = -SIZE / 2; i <= SIZE / 2; i += 10) {
    // X-axis lines (along Z)
    const geometryX = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(i, 0.05, -SIZE / 2),
      new THREE.Vector3(i, 0.05, SIZE / 2)
    ]);
    const lineX = new THREE.Line(geometryX, gridMaterial);
    gridGroup.add(lineX);

    // Z-axis lines (along X)
    const geometryZ = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-SIZE / 2, 0.05, i),
      new THREE.Vector3(SIZE / 2, 0.05, i)
    ]);
    const lineZ = new THREE.Line(geometryZ, gridMaterial);
    gridGroup.add(lineZ);

    // Skip label at origin (0,0)
    if (i !== 0) {
      // Create label for X coordinate
      const labelX = document.createElement('div');
      labelX.className = 'grid-label';
      labelX.textContent = `${i}`;
      labelX.style.position = 'absolute';
      labelX.style.color = 'black';
      labelX.style.backgroundColor = 'rgba(255,255,255,0.5)';
      labelX.style.padding = '2px 4px';
      labelX.style.borderRadius = '2px';
      labelX.style.fontSize = '10px';
      labelX.style.userSelect = 'none';
      labelX.style.pointerEvents = 'none';
      document.body.appendChild(labelX);

      const labelPoints = new THREE.Vector3(i, 0.1, -SIZE / 2 + 5);
      gridGroup.userData.labels = gridGroup.userData.labels || [];
      gridGroup.userData.labels.push({
        element: labelX,
        position: labelPoints,
        axis: 'x'
      });

      // Create label for Z coordinate
      const labelZ = document.createElement('div');
      labelZ.className = 'grid-label';
      labelZ.textContent = `${i}`;
      labelZ.style.position = 'absolute';
      labelZ.style.color = 'black';
      labelZ.style.backgroundColor = 'rgba(255,255,255,0.5)';
      labelZ.style.padding = '2px 4px';
      labelZ.style.borderRadius = '2px';
      labelZ.style.fontSize = '10px';
      labelZ.style.userSelect = 'none';
      labelZ.style.pointerEvents = 'none';
      document.body.appendChild(labelZ);

      const labelZPoints = new THREE.Vector3(-SIZE / 2 + 5, 0.1, i);
      gridGroup.userData.labels.push({
        element: labelZ,
        position: labelZPoints,
        axis: 'z'
      });
    }
  }

  scene.add(gridGroup);
}

function buildTerrain() {
  if (terrain) {
    scene.remove(terrain);
    terrain.geometry.dispose();
  }
  trees.clear();
  treeData.length = 0;

  let terrainWidth = 50;
  let terrainDepth = 100;

  if (customPoles && customPoles.length > 0) {
    const minZ = Math.min(...customPoles.map(p => p.x));
    const maxZ = Math.max(...customPoles.map(p => p.x));
    terrainDepth = (maxZ - minZ) + 40; // Add margin on both sides
    terrainOffsetZ = 0; // Don't offset the terrain
  }

  console.log(`Building terrain surface: ${terrainWidth}x${terrainDepth} units`);
  console.log(`X bounds: ${-terrainWidth/2} to ${terrainWidth/2}`);
  console.log(`Z bounds: ${-20} to ${terrainDepth-20}`);

  const g = new THREE.PlaneGeometry(terrainWidth, terrainDepth, SEG, SEG);
  g.rotateX(-Math.PI / 2);

  terrain = new THREE.Mesh(g, new THREE.MeshStandardMaterial({ color: 0x5ca55c }));
  terrain.position.z = terrainDepth/2 - 20; // Position terrain to start at -20
  scene.add(terrain);

  const positions = terrain.geometry.attributes.position;
  for (let i = 0; i < positions.count; i++) {
    const x = positions.getX(i);
    const localZ = positions.getZ(i);
    const worldZ = localZ + terrain.position.z;

    let elevation = 0;
    if (customGround) {
      elevation = customGround(x, worldZ);
    } else {
      elevation = calculateTerrainHeight(x, worldZ);
    }

    positions.setY(i, elevation);
  }

  positions.needsUpdate = true;
  terrain.geometry.computeVertexNormals();

  addGridLines();

  if (terrainSel.value === 'hillsTrees') addTrees();
}

function addTrees(){
  const trunkG=new THREE.CylinderGeometry(0.15,0.15,1,6);
  const folG=new THREE.ConeGeometry(0.75,2,8);
  const trunkM=new THREE.MeshStandardMaterial({color:0x8b5a2b});
  const folM=new THREE.MeshStandardMaterial({color:0x2e8b57});
  const cluster=20,radius=6;
  for(let cx=-SIZE/2;cx<=SIZE/2;cx+=cluster){
    for(let cz=-SIZE/2;cz<=SIZE/2;cz+=cluster){ if(Math.random()<0.35){
      const n=THREE.MathUtils.randInt(6,15);
      for(let i=0;i<n;i++){
        const ang=Math.random()*Math.PI*2, r=Math.random()*radius;
        const x=cx+Math.cos(ang)*r, z=cz+Math.sin(ang)*r, y=hAt(x,z); const s=THREE.MathUtils.randFloat(0.8,1.6);
        const trunk=new THREE.Mesh(trunkG,trunkM); trunk.scale.y=s; trunk.position.set(x,y+s*0.5,z);
        const fol=new THREE.Mesh(folG,folM); fol.scale.setScalar(s); fol.position.set(x,y+s*1.5,z);
        const t=new THREE.Group(); t.add(trunk); t.add(fol); t.userData.tree=true; trees.add(t);
        treeData.push({x,z,yTop:y+s*1.5,ref:t});
      } }} }
}
buildTerrain();

/* ------- materials ------- */
const BASE_H=10, R=0.2;
const poleGeo = new THREE.CylinderGeometry(R,R,BASE_H,8);
const mPole   = new THREE.MeshStandardMaterial({color:0x8b5a2b});
const mPoleHL = new THREE.MeshStandardMaterial({color:0xffe66d});
const mGood   = new THREE.LineBasicMaterial({color:0x000000});
const mBad    = new THREE.LineBasicMaterial({color:0xff0000});
const mGhost  = new THREE.MeshStandardMaterial({color:0x46c9ff,transparent:true,opacity:0.4});
const mTreeHL = new THREE.MeshStandardMaterial({color:0xffff8d});
const mGrid   = new THREE.LineBasicMaterial({color:0x555555, transparent:true, opacity:0.5});

/* ------- data stores ------- */
const poles=[]; // {x,z,h,base,obj}
const ray=new THREE.Raycaster(); const mouse=new THREE.Vector2();

/* ------- span build & check ------- */
function drawSpan(a, b) {
  const yA = a.base + a.h;
  const yB = b.base + b.h;
  const d = Math.hypot(b.x - a.x, b.z - a.z);
  const sag = Math.max(0.1, d * 0.05) / currentTension;
  const pts = [];

  for (let i = 0; i <= SAMPLES; i++) {
    const t = i / SAMPLES;
    const x = THREE.MathUtils.lerp(a.x, b.x, t);
    const z = THREE.MathUtils.lerp(a.z, b.z, t) + terrainOffsetZ;
    const y = THREE.MathUtils.lerp(yA, yB, t) - sag * Math.sin(Math.PI * t);
    pts.push(new THREE.Vector3(x, y, z));
  }

  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const line = new THREE.Line(geo, mGood);
  line.userData = { span: true, a: a.obj, b: b.obj };
  scene.add(line);
}
function rebuild() {
  scene.children.filter(o => o.userData.span).forEach(l => {
    l.geometry.dispose();
    scene.remove(l);
  });
  
  const initialLoad = !window.spansInitialized;
  if (initialLoad && customPoles) {
    window.spansInitialized = true;
  }
  
  for (let i = 1; i < poles.length; i++) {
    drawSpan(poles[i-1], poles[i]);
  }
}

/* ------- pole helpers ------- */
function addPole(x, z, h) {
  if (poles.some(p => p.x === x && p.z === z)) return;

  const base = hAt(x, z + terrainOffsetZ); // Adjusted to account for terrainOffsetZ
  const mesh = new THREE.Mesh(poleGeo, mPole);
  mesh.scale.y = h / BASE_H;
  mesh.position.set(x, base + h / 2, z + terrainOffsetZ); // Adjusted to align with terrainOffsetZ
  mesh.userData.pole = true;

  scene.add(mesh);
  poles.push({ x, z, h, base, obj: mesh });
  rebuild();
}
function removePole(obj){ const i=poles.findIndex(p=>p.obj===obj); if(i>-1){scene.remove(obj); poles.splice(i,1); rebuild();}}

/* ------- ghost pole ------- */
let ghost=new THREE.Mesh(poleGeo,mGhost); ghost.visible=false; scene.add(ghost);
let hoverPt=null, hoverPole=null, hoverTree=null;

// Adjust terrain alignment and raycasting logic
function updateGhost() {
  ghost.visible = false;
  if (!hoverPt || hoverPole || hoverTree) return;
  if (poles.some(p => p.x === hoverPt.x && p.z === hoverPt.z)) return;

  const h = currentH;
  const base = hAt(hoverPt.x, hoverPt.z + terrainOffsetZ); // Adjusted to account for terrainOffsetZ

  ghost.scale.y = h / BASE_H;
  ghost.position.set(hoverPt.x, base + h / 2, hoverPt.z + terrainOffsetZ); // Adjusted to align with terrainOffsetZ
  ghost.visible = true;
}

/* ------- picking helpers ------- */
function pick(evt,list){ mouse.set((evt.clientX/innerWidth)*2-1,-(evt.clientY/innerHeight)*2+1); ray.setFromCamera(mouse,camera); return ray.intersectObjects(list,true)[0]?.object||null; }
const poleMeshes=()=>poles.map(p=>p.obj);
function setTreeHL(t,on){ t.traverse(m=>{if(m.isMesh)m.material=on?mTreeHL:(m.geometry.type==='CylinderGeometry'?new THREE.MeshStandardMaterial({color:0x8b5a2b}):new THREE.MeshStandardMaterial({color:0x2e8b57}));}); }

/* ------- interaction state ------- */
let drag=null,startY=0,startH=0,clickStart=null;
let dragStartPos = null, dragStartHeight = null, dragMode = null;

window.addEventListener('contextmenu', e => {
  e.preventDefault(); // Prevent the default context menu
  const tPick = pick(e, trees.children);
  if (tPick) {
    trees.remove(tPick);
    treeData.splice(treeData.findIndex(t => t.ref === tPick), 1);
    rebuild();
    return;
  }
  
  const pPick = pick(e, poleMeshes());
  if (pPick) {
    removePole(pPick);
    return;
  }
});

window.addEventListener('pointerdown', e => {
  if (e.shiftKey) {
    return;
  }

  const pPick = pick(e, poleMeshes());
  if (pPick) {
    drag = pPick;
    startY = e.clientY;
    startX = e.clientX;
    const pole = poles.find(p => p.obj === drag);
    dragStartPos = { x: pole.x, z: pole.z };
    dragStartHeight = pole.h;
    controls.enabled = false;
    
    // If Alt key is pressed, prepare for height adjustment
    if (e.altKey) {
      dragMode = 'height';
    } else {
      dragMode = 'position';
    }
    return;
  }
  clickStart = [e.clientX, e.clientY];
});

window.addEventListener('pointermove', e => {
  // Handle pole dragging
  if (drag) {
    mouse.set((e.clientX / innerWidth) * 2 - 1, -(e.clientY / innerHeight) * 2 + 1);
    ray.setFromCamera(mouse, camera);
    const hit = ray.intersectObject(terrain, true)[0];
    
    if (hit) {
      const pole = poles.find(p => p.obj === drag);
      
      if (dragMode === 'position') {
        pole.x = SNAP(hit.point.x);
        pole.z = SNAP(hit.point.z - terrainOffsetZ);
        
        const base = hAt(pole.x, pole.z + terrainOffsetZ);
        pole.base = base;
        pole.obj.position.set(pole.x, base + pole.h / 2, pole.z + terrainOffsetZ);
      } else if (dragMode === 'height') {
        const deltaY = startY - e.clientY;
        const newHeight = Math.max(MINH, Math.min(MAXH, dragStartHeight + deltaY * DRAG_SENS));
        pole.h = SNAP(newHeight);
        pole.obj.scale.y = pole.h / BASE_H;
        pole.obj.position.y = pole.base + pole.h / 2;
      }
      
      rebuild();
    }
    return;
  }

  const pPick = pick(e, poleMeshes());
  if (pPick !== hoverPole) {
    if (hoverPole) hoverPole.material = mPole;
    hoverPole = pPick;
    if (hoverPole) hoverPole.material = mPoleHL;
  }

  const tPick = pick(e, trees.children);
  if (tPick !== hoverTree) {
    if (hoverTree) setTreeHL(hoverTree, false);
    hoverTree = tPick;
    if (hoverTree) setTreeHL(hoverTree, true);
  }

  mouse.set((e.clientX / innerWidth) * 2 - 1, -(e.clientY / innerHeight) * 2 + 1);
  ray.setFromCamera(mouse, camera);
  const hit = ray.intersectObject(terrain, true)[0];

  if (hit) {
    hoverPt = {
      x: SNAP(hit.point.x),
      z: SNAP(hit.point.z - terrainOffsetZ),
    };
  } else {
    hoverPt = null;
  }

  updateGhost();
});

window.addEventListener('pointerup', e => {
  if (drag) {
    drag = null;
    controls.enabled = true;
    return;
  }
  if (!clickStart) return;
  const [dx, dy] = [Math.abs(e.clientX - clickStart[0]), Math.abs(e.clientY - clickStart[1])];
  clickStart = null;
  if (dx < 5 && dy < 5 && hoverPt) {
    const h = currentH;
    const base = hAt(hoverPt.x, hoverPt.z + terrainOffsetZ);
    addPole(hoverPt.x, hoverPt.z, h);
    updateGhost();
  }
});

function resetScene(){ poles.forEach(p=>scene.remove(p.obj)); poles.length=0; scene.children.filter(o=>o.userData.span).forEach(l=>{l.geometry.dispose();scene.remove(l);}); updateGhost();}

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* ------- geometric calculations ------- */
function round2(value) {
  return value === null ? null : parseFloat(value.toFixed(2));
}

function calculateDistance(p1, p2) {
  return Math.hypot(p2.x - p1.x, p2.z - p1.z);
}

function calculateAngle(p1, p2) {
  return Math.atan2(p2.z - p1.z, p2.x - p1.x) * (180 / Math.PI);
}

function calculateInclinationAngle(p1, p2) {
  const dx = p2.x - p1.x;
  const dz = p2.z - p1.z;
  const dy = (p2.base + p2.h) - (p1.base + p1.h);
  const horizontalDistance = Math.hypot(dx, dz);
  
  return Math.atan2(dy, horizontalDistance) * (180 / Math.PI);
}

function calculateCatenaryAngles(p1, p2, tensionFactor) {
  const horizontalDistance = calculateDistance(p1, p2);
  if (horizontalDistance === 0) return { departureAngle: 0, arrivalAngle: 0 };
  
  const height1 = p1.base + p1.h;
  const height2 = p2.base + p2.h;
  const heightDiff = height2 - height1;
  
  const sag = Math.max(0.1, horizontalDistance * 0.05) / tensionFactor;
  
  const baseSlopeAngle = Math.atan2(heightDiff, horizontalDistance);
  const sagEffect = Math.atan(Math.PI * sag / horizontalDistance);
  
  const departureAngle = (baseSlopeAngle + sagEffect) * (180 / Math.PI);
  const arrivalAngle = (baseSlopeAngle - sagEffect) * (180 / Math.PI);
  
  return { departureAngle, arrivalAngle };
}

function calculateSpanLength(p1, p2, sag) {
  const distance = calculateDistance(p1, p2);
  if (distance === 0) return 0;
  
  // Approximate the conductor length with discrete integration over catenary curve
  const segments = 50;
  let length = 0;
  const height1 = p1.base + p1.h;
  const height2 = p2.base + p2.h;
  
  for (let i = 0; i < segments; i++) {
    const t1 = i / segments;
    const t2 = (i + 1) / segments;
    
    const x1 = p1.x + (p2.x - p1.x) * t1;
    const z1 = p1.z + (p2.z - p1.z) * t1;
    const y1 = height1 + (height2 - height1) * t1 - sag * Math.sin(Math.PI * t1);
    
    const x2 = p1.x + (p2.x - p1.x) * t2;
    const z2 = p1.z + (p2.z - p1.z) * t2;
    const y2 = height1 + (height2 - height1) * t2 - sag * Math.sin(Math.PI * t2);
    
    length += Math.hypot(x2 - x1, y2 - y1, z2 - z1);
  }
  
  return length;
}

function calculateTopAngle(p1, p2, p3) {
  const angle1 = calculateAngle(p2, p1);
  const angle2 = calculateAngle(p2, p3);
  
  let diff = Math.abs(angle2 - angle1);
  if (diff > 180) diff = 360 - diff;
  
  return diff;
}


function collectData() {
  const polesData = poles.map((p, index) => {
    const nextPole = index < poles.length - 1 ? poles[index + 1] : null;
    const prevPole = index > 0 ? poles[index - 1] : null;
    
    const distanceToNext = nextPole ? calculateDistance(p, nextPole) : 0;
    const sag = nextPole ? Math.max(0.1, distanceToNext * 0.05) / currentTension : 0;
    
    let departureAngle = null;
    let arrivalAngle = null;
    
    if (nextPole) {
      const angles = calculateCatenaryAngles(p, nextPole, currentTension);
      departureAngle = angles.departureAngle;
    }
    
    if (prevPole) {
      const angles = calculateCatenaryAngles(prevPole, p, currentTension);
      arrivalAngle = angles.arrivalAngle;
    }
    
    const topAngle = (prevPole && nextPole) ? calculateTopAngle(prevPole, p, nextPole) : null;
    
    return {
      id: index + 1,
      x: round2(p.x),
      z: round2(p.z),
      height: round2(p.h),
      baseElevation: round2(p.base),
      nextPoleId: nextPole ? index + 2 : null,
      distanceToNext: round2(distanceToNext),
      arrivalAngle: round2(arrivalAngle),
      departureAngle: round2(departureAngle),
      topAngle: round2(topAngle)
    };
  });
  
  const spansData = [];
  for (let i = 0; i < poles.length - 1; i++) {
    const a = poles[i];
    const b = poles[i + 1];
    const distance = calculateDistance(a, b);
    const sag = Math.max(0.1, distance * 0.05) / currentTension;
    const angles = calculateCatenaryAngles(a, b, currentTension);
    const straightLineSlope = calculateInclinationAngle(a, b);
    
    const span = scene.children.find(o => 
      o.userData.span && 
      o.userData.a === a.obj && 
      o.userData.b === b.obj
    );
    
    spansData.push({
      fromPoleId: i + 1,
      toPoleId: i + 2,
      distance: round2(distance),
      length: round2(calculateSpanLength(a, b, sag)),
      departureAngle: round2(angles.departureAngle),
      arrivalAngle: round2(angles.arrivalAngle),
      sagDistance: round2(sag),
      straightLineSlope: round2(straightLineSlope),
      valid: span ? span.material === mGood : false
    });
  }
  
  return {
    poles: polesData,
    spans: spansData,
    terrain: terrainSel.value,
    tensionMultiplier: currentTension
  };
}

// Place custom poles on load
if (customPoles) {
  poles.length = 0;
  
  // Extract any scaling factor that was applied to the elevations
  let elevScaleFactor = 1;
  const elevRange = Math.max(...useElevations) - Math.min(...useElevations);
  if (elevRange > 30) {
    const targetElevRange = 20;
    elevScaleFactor = targetElevRange / elevRange;
    console.log(`Using elevation scale factor for pole heights: ${elevScaleFactor.toFixed(2)}`);
  }
  
  for (const pole of customPoles) {
    const mesh = new THREE.Mesh(poleGeo, mPole);
    
    // Scale pole height proportionally if elevations were scaled
    const scaledHeight = elevScaleFactor !== 1 ? pole.h * elevScaleFactor : pole.h;
    mesh.scale.y = scaledHeight / BASE_H;
    
    const zPos = pole.x;
    const base = pole.elev;
    
    mesh.position.set(0, base + scaledHeight / 2, zPos + terrainOffsetZ);
    mesh.userData.pole = true;
    scene.add(mesh);
    poles.push({ x: 0, z: zPos, h: scaledHeight, base, obj: mesh });
  }
  rebuild();
}

(function loop(){ 
  requestAnimationFrame(loop); 
  controls.update();
  
  // Update grid labels position if they exist
  scene.children.filter(o => o.userData.grid && o.userData.labels).forEach(grid => {
    if (grid.userData.labels) {
      grid.userData.labels.forEach(label => {
        const screenPosition = label.position.clone();
        screenPosition.project(camera);
        
        const x = (screenPosition.x * 0.5 + 0.5) * innerWidth;
        const y = (-(screenPosition.y * 0.5) + 0.5) * innerHeight;
        
        if (screenPosition.z < 1) {
          label.element.style.display = 'block';
          label.element.style.transform = `translate(-50%, -50%)`;
          label.element.style.left = `${x}px`;
          label.element.style.top = `${y}px`;
        } else {
          label.element.style.display = 'none';
        }
      });
    }
  });
  
  renderer.render(scene,camera);
})();


</script>
</body>
</html>
